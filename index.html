<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AndroidVR - Enhanced H-band 3D Rotation</title>
    <style>
        /* Keep ALL your original styles exactly as they are */
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
            color: #fff;
            min-height: 100vh;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88;
            margin-bottom: 10px;
        }

        .subtitle {
            text-align: center;
            color: #888;
            font-size: 14px;
            margin-bottom: 30px;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        label {
            color: #00ff88;
            margin-bottom: 5px;
            font-size: 12px;
            text-transform: uppercase;
        }

        input[type="range"] {
            width: 100%;
            margin-bottom: 10px;
        }

        input[type="number"] {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #00ff88;
            border-radius: 5px;
            color: #fff;
            padding: 5px;
            font-size: 12px;
            width: 80px;
        }

        input[type="file"] {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #00ff88;
            border-radius: 5px;
            color: #fff;
            padding: 5px;
        }

        select, button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #00ff88;
            border-radius: 5px;
            color: #fff;
            padding: 5px;
            cursor: pointer;
        }

        button:hover {
            background: rgba(0, 255, 136, 0.2);
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
        }

        .band-control {
            background: rgba(255, 255, 0, 0.2) !important;
            border-color: #ffff00 !important;
        }

        .hadit-control {
            background: rgba(255, 0, 255, 0.2) !important;
            border-color: #ff00ff !important;
        }

        .stereo-fix {
            background: rgba(255, 68, 136, 0.2) !important;
            border-color: #ff4488 !important;
        }

        .depth-viz {
            background: rgba(255, 136, 0, 0.2) !important;
            border-color: #ff8800 !important;
        }

        .precision-control {
            background: rgba(0, 255, 255, 0.2) !important;
            border-color: #00ffff !important;
        }

        .rotation-control {
            background: rgba(136, 68, 255, 0.2) !important;
            border-color: #8844ff !important;
        }

        .canvas-container {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        canvas {
            border: 2px solid #00ff88;
            border-radius: 10px;
            background: #000;
            max-width: 100%;
            height: auto;
            cursor: grab;
        }

        canvas:active {
            cursor: grabbing;
        }

        .left-eye { border-color: #ff4444 !important; }
        .right-eye { border-color: #4444ff !important; }
        .depth-map { border-color: #ff8800 !important; }
        .rotated-view { border-color: #8844ff !important; }

        .canvas-label {
            text-align: center;
            font-size: 12px;
            color: #888;
            margin-bottom: 5px;
            text-transform: uppercase;
        }

        .left-label { color: #ff4444; }
        .right-label { color: #4444ff; }
        .depth-label { color: #ff8800; }
        .rotation-label { color: #8844ff; }

        .analysis-panel {
            background: rgba(136, 255, 0, 0.1);
            border: 1px solid #88ff00;
            border-radius: 10px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            overflow-y: auto;
            max-height: 400px;
        }

        .info-panel {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid #00ff88;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }

        .hadit-info {
            background: rgba(255, 0, 255, 0.1);
            border: 1px solid #ff00ff;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            font-size: 12px;
        }

        .rotation-info {
            background: rgba(136, 68, 255, 0.1);
            border: 1px solid #8844ff;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            font-size: 12px;
        }

        .dual-input {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .dual-input input[type="range"] {
            flex: 1;
            margin-bottom: 0;
        }

        .dual-input input[type="number"] {
            flex: 0 0 auto;
        }

        .processing {
            box-shadow: 0 0 20px rgba(255, 255, 0, 0.5) !important;
            animation: processing 1s ease-in-out infinite;
        }

        @keyframes processing {
            0% { box-shadow: 0 0 20px rgba(255, 255, 0, 0.3); }
            50% { box-shadow: 0 0 40px rgba(255, 255, 0, 0.8); }
            100% { box-shadow: 0 0 20px rgba(255, 255, 0, 0.3); }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>AndroidVR - Enhanced H-band 3D Rotation</h1>
        <div class="subtitle">Fixed uniform S-coordinate application | Angledcrystals | 2025-06-08 05:18:59 UTC</div>

        <div class="hadit-info">
            <div style="color: #ff00ff; font-weight: bold;">‚ö° Fine Hadit Control:</div>
            <div>‚Ä¢ Œ∏ (Theta): 0¬∞ to 360¬∞ in 0.1¬∞ increments</div>
            <div>‚Ä¢ œÜ (Phi): 0.1¬∞ to 180¬∞ in 0.1¬∞ increments</div>
            <div>‚Ä¢ Direct number input for exact values</div>
            <div>‚Ä¢ Synchronized sliders and number inputs</div>
            <div>‚Ä¢ Mathematical edge cases handled (œÜ=0¬∞ and œÜ=180¬∞)</div>
        </div>

        <div class="rotation-info">
            <div style="color: #8844ff; font-weight: bold;">üîÑ Fixed Uniform H-band 3D Rotation:</div>
            <div>‚Ä¢ Minimal changes to your working 3D transformation</div>
            <div>‚Ä¢ S-coordinates now applied uniformly to ALL pixels</div>
            <div>‚Ä¢ Original orientation and perspective maintained</div>
            <div>‚Ä¢ Enhanced H-band visibility preserved</div>
            <div>‚Ä¢ Fixed non-uniform transformation issue</div>
        </div>

        <!-- Keep ALL your original controls exactly as they are -->
        <div class="controls">
            <div class="control-group">
                <label>Image Upload</label>
                <input type="file" id="imageUpload" accept="image/*">
            </div>
            
            <div class="control-group">
                <label>üì° Band Detection Mode</label>
                <select id="bandDetectionMode" class="band-control">
                    <option value="auto_detect" selected>üîç Auto-Detect Band</option>
                    <option value="content_analysis">üìä Content Analysis</option>
                    <option value="gradient_based">üåä Gradient-Based</option>
                    <option value="statistical">üìà Statistical Analysis</option>
                    <option value="manual_range">‚úã Manual Range</option>
                    <option value="full_image">üåç Full Image Coverage</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>üîß Band Size Multiplier: <span id="bandSizeMultiplierValue">1.0x</span></label>
                <input type="range" id="bandSizeMultiplier" min="0.1" max="10.0" step="0.1" value="1.0" class="band-control">
            </div>
            
            <div class="control-group">
                <label>üéØ Focus Factor: <span id="focusFactorValue">2.0x</span></label>
                <input type="range" id="focusFactor" min="1.0" max="5.0" step="0.1" value="2.0" class="band-control">
            </div>
            
            <div class="control-group">
                <label>‚ö° Hadit Œ∏ (Theta): <span id="haditThetaValue">45.0¬∞</span></label>
                <div class="dual-input">
                    <input type="range" id="haditTheta" min="0" max="360" value="45" step="0.1" class="hadit-control">
                    <input type="number" id="haditThetaNumber" min="0" max="360" step="0.1" value="45" class="hadit-control">
                </div>
            </div>
            
            <div class="control-group">
                <label>‚ö° Hadit œÜ (Phi): <span id="haditPhiValue">60.0¬∞</span></label>
                <div class="dual-input">
                    <input type="range" id="haditPhi" min="0.1" max="179.9" value="60" step="0.1" class="hadit-control">
                    <input type="number" id="haditPhiNumber" min="0.1" max="179.9" step="0.1" value="60" class="hadit-control">
                </div>
            </div>
            
            <div class="control-group">
                <label>üåä Hadit Influence: <span id="haditInfluenceValue">1.0</span></label>
                <input type="range" id="haditInfluence" min="0" max="2" value="1.0" step="0.1" class="hadit-control">
            </div>
            
            <div class="control-group">
                <label>üìê S Bounds: <span id="sBoundsValue">¬±10.0</span></label>
                <input type="range" id="sBounds" min="1.0" max="20.0" step="0.1" value="10.0" class="band-control">
            </div>
            
            <div class="control-group">
                <label>üîÑ 3D Rotation X: <span id="rotationXValue">0.0¬∞</span></label>
                <div class="dual-input">
                    <input type="range" id="rotationX" min="-30" max="30" value="0" step="0.1" class="rotation-control">
                    <input type="number" id="rotationXNumber" min="-30" max="30" step="0.1" value="0" class="rotation-control">
                </div>
            </div>
            
            <div class="control-group">
                <label>üîÑ 3D Rotation Y: <span id="rotationYValue">0.0¬∞</span></label>
                <div class="dual-input">
                    <input type="range" id="rotationY" min="-45" max="45" value="0" step="0.1" class="rotation-control">
                    <input type="number" id="rotationYNumber" min="-45" max="45" step="0.1" value="0" class="rotation-control">
                </div>
            </div>
            
            <div class="control-group">
                <label>üèîÔ∏è 3D Depth Scale: <span id="depthScaleValue">2.0x</span></label>
                <input type="range" id="depthScale" min="0.5" max="5.0" step="0.1" value="2.0" class="rotation-control">
            </div>
            
            <div class="control-group">
                <label>üé¨ View Distance: <span id="viewDistanceValue">3.0</span></label>
                <input type="range" id="viewDistance" min="1.5" max="6.0" step="0.1" value="3.0" class="rotation-control">
            </div>
            
            <div class="control-group">
                <label>üí° Luminosity Weight: <span id="luminosityWeightValue">0.7</span></label>
                <input type="range" id="luminosityWeight" min="0" max="1" step="0.05" value="0.7" class="band-control">
            </div>
            
            <div class="control-group">
                <label>üåà Saturation Weight: <span id="saturationWeightValue">0.3</span></label>
                <input type="range" id="saturationWeight" min="0" max="1" step="0.05" value="0.3" class="band-control">
            </div>
            
            <div class="control-group">
                <label>üîß Stereo Separation: <span id="separationValue">8px</span></label>
                <input type="range" id="separation" min="0" max="20" value="8" step="1" class="stereo-fix">
            </div>
            
            <div class="control-group">
                <label>üó∫Ô∏è Depth Contrast: <span id="depthContrastValue">1.2x</span></label>
                <input type="range" id="depthContrast" min="0.1" max="3" value="1.2" step="0.1" class="depth-viz">
            </div>
            
            <div class="control-group">
                <label>Precision Presets</label>
                <button id="setHadit1Degree" class="precision-control">Set œÜ to 1.0¬∞</button>
                <button id="setHadit01Degree" class="precision-control">Set œÜ to 0.1¬∞</button>
                <button id="setHaditNearZero" class="precision-control">Set œÜ to 0.5¬∞</button>
                <button id="setHaditNear180" class="precision-control">Set œÜ to 179.5¬∞</button>
            </div>
            
            <div class="control-group">
                <label>3D Rotation Presets</label>
                <button id="resetRotation" class="rotation-control">üîÑ Reset View</button>
                <button id="topView" class="rotation-control">‚¨ÜÔ∏è Top View</button>
                <button id="sideView" class="rotation-control">‚û°Ô∏è Side View</button>
                <button id="isometricView" class="rotation-control">üìê Isometric</button>
            </div>
            
            <div class="control-group">
                <label>Actions</label>
                <button id="detectBand" class="band-control">üì° Detect Band</button>
                <button id="expandBandFull" class="band-control">üåç Expand Full</button>
                <button id="testPattern" class="stereo-fix">üéØ Test Pattern</button>
                <button id="animateHadit" class="hadit-control">üåÄ Animate Hadit</button>
                <button id="export3D" class="rotation-control">üíæ Export 3D</button>
                <button id="clearAll">üîÑ Clear All</button>
            </div>
            
            <div class="control-group">
                <label>Options</label>
                <label><input type="checkbox" id="enableStereo" checked> Enable Stereo</label>
                <label><input type="checkbox" id="showBandVisualization"> Show Band Viz</label>
                <label><input type="checkbox" id="realTimeUpdate" checked> Real-time Update</label>
                <label><input type="checkbox" id="focusOnlyBand"> Focus Only Band</label>
                <label><input type="checkbox" id="cleanDepthMap" checked> Clean Depth Map</label>
                <label><input type="checkbox" id="enable3DRotation" checked> Enable 3D Rotation</label>
                <label><input type="checkbox" id="enhanceBandDepth" checked> Enhance Band Depth</label>
            </div>
        </div>

        <div class="info-panel" id="infoPanel">
            <div>Status: Fixed uniform H-band 3D rotation ready... | Angledcrystals | 2025-06-08 05:18:59 UTC</div>
        </div>

        <div class="canvas-container">
            <div>
                <div class="canvas-label left-label">Left Eye View</div>
                <canvas id="leftCanvas" width="400" height="300" class="left-eye"></canvas>
            </div>
            <div>
                <div class="canvas-label right-label">Right Eye View</div>
                <canvas id="rightCanvas" width="400" height="300" class="right-eye"></canvas>
            </div>
            <div>
                <div class="canvas-label depth-label">Fine Hadit Depth</div>
                <canvas id="depthCanvas" width="400" height="300" class="depth-map"></canvas>
            </div>
            <div>
                <div class="canvas-label rotation-label">Enhanced 3D View</div>
                <canvas id="rotatedCanvas" width="400" height="300" class="rotated-view"></canvas>
            </div>
        </div>

        <div class="analysis-panel" id="analysisPanel">
            <div style="color: #88ff00; font-weight: bold;">‚ö° Enhanced H-band 3D Analysis</div>
            <div>Ready for enhanced H-band depth decoding and 3D rotation...</div>
        </div>
    </div>

    <script>
        // Keep ALL your original Hadit mathematics exactly as they are
        const vectorOps = {
            dot: (a, b) => a.x * b.x + a.y * b.y + a.z * b.z,
            subtract: (a, b) => ({ x: a.x - b.x, y: a.y - b.y, z: a.z - b.z }),
            scale: (v, s) => ({ x: v.x * s, y: v.y * s, z: v.z * s }),
            normalize: (v) => {
                const mag = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
                return mag > 1e-10 ? vectorOps.scale(v, 1 / mag) : { x: 0, y: 0, z: 1 };
            }
        };

        function sphericalToCartesian(theta, phi) {
            const clampedPhi = Math.max(0.1, Math.min(179.9, phi));
            const thetaRad = theta * Math.PI / 180;
            const phiRad = clampedPhi * Math.PI / 180;
            
            return {
                x: Math.sin(phiRad) * Math.cos(thetaRad),
                y: Math.sin(phiRad) * Math.sin(thetaRad),
                z: Math.cos(phiRad)
            };
        }

        function householderReflection(G_3d, hadit_3d) {
            const haditUnit = vectorOps.normalize(hadit_3d);
            const dotProduct = vectorOps.dot(haditUnit, G_3d);
            return vectorOps.subtract(G_3d, vectorOps.scale(haditUnit, 2 * dotProduct));
        }

        function stereographicProjection(G_reflected) {
            if (Math.abs(1 - G_reflected.z) < 1e-10) {
                return { x: 0, y: 0 };
            }
            return {
                x: G_reflected.x / (1 - G_reflected.z),
                y: G_reflected.y / (1 - G_reflected.z)
            };
        }

        // Keep ALL your original band detection exactly as it is
        let currentSBounds = 10.0;
        let detectedBand = { min: 0, max: 0, center: 0, width: 0, confidence: 0 };
        
        function calculateHaditModulatedSCoordinate(px, py, width, height, lum, sat, config) {
            const gTheta = (px / width) * 360;
            const gPhi = (py / height) * 180;
            const G_3d = sphericalToCartesian(gTheta, gPhi);
            
            const hadit_3d = sphericalToCartesian(config.haditTheta, config.haditPhi);
            const G_reflected = householderReflection(G_3d, hadit_3d);
            const S_hadit = stereographicProjection(G_reflected);
            
            const lumMapWeight = config.luminosityWeight;
            const satMapWeight = config.saturationWeight;
            const contentModulation = (1 + lum * lumMapWeight + sat * satMapWeight);
            
            const S_modulated = {
                x: S_hadit.x * contentModulation * config.haditInfluence,
                y: S_hadit.y * contentModulation * config.haditInfluence
            };
            
            const sMagnitude = Math.sqrt(S_modulated.x * S_modulated.x + S_modulated.y * S_modulated.y);
            
            return {
                sCoord: S_modulated,
                sMagnitude: sMagnitude,
                originalG: G_3d,
                reflectedG: G_reflected,
                haditVector: hadit_3d,
                contentModulation: contentModulation,
                luminance: lum,
                saturation: sat
            };
        }
        
        // Keep ALL your detection functions exactly as they are
        function detectHaditInformationBand(imageData, config) {
            console.log(`üì° Detecting band with Hadit Œ∏=${config.haditTheta.toFixed(1)}¬∞, œÜ=${config.haditPhi.toFixed(1)}¬∞`);
            const startTime = performance.now();
            
            const { width, height, data } = imageData;
            const sMagnitudeHistogram = new Array(200).fill(0);
            const contentHistogram = new Array(200).fill(0);
            
            const maxSMagnitude = currentSBounds * 2;
            let totalPixels = 0;
            let totalContent = 0;
            
            const sampleStep = Math.max(1, Math.floor(Math.min(width, height) / 50));
            
            for (let y = 0; y < height; y += sampleStep) {
                for (let x = 0; x < width; x += sampleStep) {
                    const pixelIdx = (y * width + x) * 4;
                    
                    const r = data[pixelIdx] / 255;
                    const g = data[pixelIdx + 1] / 255;
                    const b = data[pixelIdx + 2] / 255;
                    
                    const lum = 0.299 * r + 0.587 * g + 0.114 * b;
                    const maxCol = Math.max(r, g, b);
                    const minCol = Math.min(r, g, b);
                    const sat = maxCol > 0 ? (maxCol - minCol) / maxCol : 0;
                    
                    const result = calculateHaditModulatedSCoordinate(x, y, width, height, lum, sat, config);
                    const sMagnitude = result.sMagnitude;
                    
                    const contentImportance = lum * 0.5 + sat * 0.3 + 
                                            (Math.abs(r - g) + Math.abs(g - b) + Math.abs(b - r)) * 0.2;
                    
                    const binIndex = Math.floor((sMagnitude / maxSMagnitude) * (sMagnitudeHistogram.length - 1));
                    if (binIndex >= 0 && binIndex < sMagnitudeHistogram.length) {
                        sMagnitudeHistogram[binIndex]++;
                        contentHistogram[binIndex] += contentImportance;
                        totalContent += contentImportance;
                    }
                    
                    totalPixels++;
                }
            }
            
            let bandDetectionResult;
            
            switch (config.bandDetectionMode) {
                case 'full_image':
                    bandDetectionResult = {
                        min: 0,
                        max: maxSMagnitude * 2,
                        center: maxSMagnitude,
                        width: maxSMagnitude * 2,
                        confidence: 1.0
                    };
                    break;
                    
                case 'auto_detect':
                    bandDetectionResult = autoDetectBand(sMagnitudeHistogram, contentHistogram, maxSMagnitude, config.bandSensitivity);
                    break;
                    
                case 'content_analysis':
                    bandDetectionResult = contentBasedBandDetection(contentHistogram, maxSMagnitude, config.bandSensitivity);
                    break;
                    
                case 'gradient_based':
                    bandDetectionResult = gradientBasedBandDetection(sMagnitudeHistogram, maxSMagnitude, config.bandSensitivity);
                    break;
                    
                case 'statistical':
                    bandDetectionResult = statisticalBandDetection(sMagnitudeHistogram, contentHistogram, maxSMagnitude, config.bandSensitivity);
                    break;
                    
                case 'manual_range':
                    bandDetectionResult = {
                        min: config.manualBandMin || 0,
                        max: config.manualBandMax || maxSMagnitude,
                        center: (config.manualBandMin + config.manualBandMax) / 2,
                        width: config.manualBandMax - config.manualBandMin,
                        confidence: 1.0
                    };
                    break;
            }
            
            // Apply band size multiplier
            if (config.bandSizeMultiplier !== 1.0) {
                const originalWidth = bandDetectionResult.width;
                const newWidth = originalWidth * config.bandSizeMultiplier;
                const expansion = (newWidth - originalWidth) / 2;
                
                bandDetectionResult.min = Math.max(0, bandDetectionResult.min - expansion);
                bandDetectionResult.max = bandDetectionResult.max + expansion;
                bandDetectionResult.width = newWidth;
            }
            
            const processingTime = performance.now() - startTime;
            
            console.log(`‚úÖ Band detection completed in ${processingTime.toFixed(2)}ms`);
            console.log(`   Detected band: ${bandDetectionResult.min.toFixed(2)} to ${bandDetectionResult.max.toFixed(2)}`);
            
            return {
                band: bandDetectionResult,
                histograms: {
                    sMagnitude: sMagnitudeHistogram,
                    content: contentHistogram
                },
                stats: {
                    processingTime,
                    totalPixels,
                    totalContent,
                    maxSMagnitude,
                    samplingStep: sampleStep
                }
            };
        }
        
        function autoDetectBand(sMagnitudeHistogram, contentHistogram, maxSMagnitude, sensitivity = 0.5) {
            const smoothedContent = smoothHistogram(contentHistogram, 3);
            const peaks = findHistogramPeaks(smoothedContent, sensitivity);
            
            if (peaks.length === 0) {
                return { min: 0, max: maxSMagnitude, center: maxSMagnitude / 2, width: maxSMagnitude, confidence: 0.1 };
            }
            
            const primaryPeak = peaks.reduce((max, peak) => peak.strength > max.strength ? peak : max);
            const bandHalfWidth = Math.max(0.5, maxSMagnitude * 0.1);
            const binToSMagnitude = (bin) => (bin / (smoothedContent.length - 1)) * maxSMagnitude;
            
            const bandCenter = binToSMagnitude(primaryPeak.bin);
            const bandMin = Math.max(0, bandCenter - bandHalfWidth);
            const bandMax = Math.min(maxSMagnitude, bandCenter + bandHalfWidth);
            
            return {
                min: bandMin,
                max: bandMax,
                center: bandCenter,
                width: bandMax - bandMin,
                confidence: Math.min(1.0, primaryPeak.strength / (smoothedContent.length * 0.1))
            };
        }
        
        function contentBasedBandDetection(contentHistogram, maxSMagnitude, sensitivity = 0.5) {
            let totalContent = contentHistogram.reduce((sum, val) => sum + val, 0);
            if (totalContent === 0) {
                return { min: 0, max: maxSMagnitude, center: maxSMagnitude / 2, width: maxSMagnitude, confidence: 0.1 };
            }
            
            let weightedSum = 0;
            for (let i = 0; i < contentHistogram.length; i++) {
                weightedSum += i * contentHistogram[i];
            }
            const centerOfMass = weightedSum / totalContent;
            
            const threshold = totalContent * sensitivity * 0.01;
            let minBin = 0, maxBin = contentHistogram.length - 1;
            
            for (let i = 0; i < contentHistogram.length; i++) {
                if (contentHistogram[i] > threshold) {
                    minBin = i;
                    break;
                }
            }
            
            for (let i = contentHistogram.length - 1; i >= 0; i--) {
                if (contentHistogram[i] > threshold) {
                    maxBin = i;
                    break;
                }
            }
            
            const binToSMagnitude = (bin) => (bin / (contentHistogram.length - 1)) * maxSMagnitude;
            
            return {
                min: binToSMagnitude(minBin),
                max: binToSMagnitude(maxBin),
                center: binToSMagnitude(centerOfMass),
                width: binToSMagnitude(maxBin) - binToSMagnitude(minBin),
                confidence: Math.min(1.0, (maxBin - minBin) / (contentHistogram.length * 0.5))
            };
        }
        
        function gradientBasedBandDetection(sMagnitudeHistogram, maxSMagnitude, sensitivity = 0.5) {
            const gradient = [];
            for (let i = 1; i < sMagnitudeHistogram.length - 1; i++) {
                gradient[i] = sMagnitudeHistogram[i + 1] - sMagnitudeHistogram[i - 1];
            }
            
            const threshold = Math.max(...gradient) * sensitivity;
            let risingEdges = [];
            let fallingEdges = [];
            
            for (let i = 0; i < gradient.length; i++) {
                if (gradient[i] > threshold) risingEdges.push(i);
                if (gradient[i] < -threshold) fallingEdges.push(i);
            }
            
            if (risingEdges.length === 0 || fallingEdges.length === 0) {
                return { min: 0, max: maxSMagnitude, center: maxSMagnitude / 2, width: maxSMagnitude, confidence: 0.1 };
            }
            
            const binToSMagnitude = (bin) => (bin / (sMagnitudeHistogram.length - 1)) * maxSMagnitude;
            const bandMin = binToSMagnitude(risingEdges[0]);
            const bandMax = binToSMagnitude(fallingEdges[fallingEdges.length - 1]);
            
            return {
                min: bandMin,
                max: bandMax,
                center: (bandMin + bandMax) / 2,
                width: bandMax - bandMin,
                confidence: Math.min(1.0, (risingEdges.length + fallingEdges.length) / 10)
            };
        }
        
        function statisticalBandDetection(sMagnitudeHistogram, contentHistogram, maxSMagnitude, sensitivity = 0.5) {
            let mean = 0, variance = 0, total = 0;
            
            for (let i = 0; i < sMagnitudeHistogram.length; i++) {
                const count = sMagnitudeHistogram[i];
                mean += i * count;
                total += count;
            }
            
            if (total === 0) {
                return { min: 0, max: maxSMagnitude, center: maxSMagnitude / 2, width: maxSMagnitude, confidence: 0.1 };
            }
            
            mean /= total;
            
            for (let i = 0; i < sMagnitudeHistogram.length; i++) {
                const count = sMagnitudeHistogram[i];
                variance += Math.pow(i - mean, 2) * count;
            }
            variance /= total;
            
            const stdDev = Math.sqrt(variance);
            const bandHalfWidth = stdDev * (2 - sensitivity);
            
            const binToSMagnitude = (bin) => (bin / (sMagnitudeHistogram.length - 1)) * maxSMagnitude;
            const center = binToSMagnitude(mean);
            const bandMin = Math.max(0, center - binToSMagnitude(bandHalfWidth));
            const bandMax = Math.min(maxSMagnitude, center + binToSMagnitude(bandHalfWidth));
            
            return {
                min: bandMin,
                max: bandMax,
                center: center,
                width: bandMax - bandMin,
                confidence: Math.min(1.0, stdDev / (sMagnitudeHistogram.length * 0.2))
            };
        }
        
        function smoothHistogram(histogram, radius) {
            const smoothed = new Array(histogram.length).fill(0);
            for (let i = 0; i < histogram.length; i++) {
                let sum = 0, count = 0;
                for (let j = Math.max(0, i - radius); j <= Math.min(histogram.length - 1, i + radius); j++) {
                    sum += histogram[j];
                    count++;
                }
                smoothed[i] = sum / count;
            }
            return smoothed;
        }
        
        function findHistogramPeaks(histogram, sensitivity = 0.5) {
            const peaks = [];
            const minPeakHeight = Math.max(...histogram) * sensitivity * 0.1;
            
            for (let i = 1; i < histogram.length - 1; i++) {
                if (histogram[i] > histogram[i - 1] && 
                    histogram[i] > histogram[i + 1] && 
                    histogram[i] > minPeakHeight) {
                    peaks.push({
                        bin: i,
                        strength: histogram[i]
                    });
                }
            }
            
            return peaks;
        }

        // Keep ALL your depth generation exactly as it is
        function generateBandFocusedDepth(imageData, config, detectedBand) {
            console.log('üì° Generating precise Hadit depth map...');
            const startTime = performance.now();
            
            const { width, height, data } = imageData;
            const depthBuffer = new Array(width * height);
            
            currentSBounds = config.sBounds;
            
            let minDepth = 1, maxDepth = 0, totalDepth = 0;
            let pixelsInBand = 0, pixelsOutsideBand = 0;
            let bandDepthSum = 0, outsideDepthSum = 0;
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;
                    const pixelIdx = idx * 4;
                    
                    const r = data[pixelIdx] / 255;
                    const g = data[pixelIdx + 1] / 255;
                    const b = data[pixelIdx + 2] / 255;
                    
                    const lum = 0.299 * r + 0.587 * g + 0.114 * b;
                    const maxCol = Math.max(r, g, b);
                    const minCol = Math.min(r, g, b);
                    const sat = maxCol > 0 ? (maxCol - minCol) / maxCol : 0;
                    
                    const result = calculateHaditModulatedSCoordinate(x, y, width, height, lum, sat, config);
                    const { sCoord, sMagnitude } = result;
                    
                    const isInBand = sMagnitude >= detectedBand.min && sMagnitude <= detectedBand.max;
                    const distanceFromBandCenter = Math.abs(sMagnitude - detectedBand.center);
                    const bandPosition = Math.max(0, Math.min(1, (sMagnitude - detectedBand.min) / Math.max(0.001, detectedBand.width)));
                    
                    let depth = 0.1;
                    
                    if (isInBand) {
                        pixelsInBand++;
                        
                        const bandCenteredness = detectedBand.width > 0 ? 
                            1.0 - (distanceFromBandCenter / (detectedBand.width * 0.5)) : 1.0;
                        const contentWeight = lum * 0.5 + sat * 0.3;
                        
                        depth = 0.3 + bandPosition * 0.6;
                        depth *= (1 + Math.max(0, bandCenteredness) * config.focusFactor * 0.2);
                        depth *= (1 + contentWeight * 0.3);
                        
                        bandDepthSum += depth;
                        
                    } else {
                        pixelsOutsideBand++;
                        
                        if (config.focusOnlyBand) {
                            depth = 0.05 + (lum * 0.1);
                        } else {
                            const falloffDistance = Math.min(
                                Math.abs(sMagnitude - detectedBand.min),
                                Math.abs(sMagnitude - detectedBand.max)
                            );
                            const falloffFactor = 1.0 / (1.0 + falloffDistance * 0.5);
                            depth = 0.1 + lum * 0.2 * falloffFactor;
                        }
                        
                        outsideDepthSum += depth;
                    }
                    
                    if (isInBand && config.focusFactor > 1.0) {
                        depth = 0.5 + (depth - 0.5) * config.focusFactor;
                    }
                    
                    depth = Math.max(0.05, Math.min(1.0, depth));
                    
                    minDepth = Math.min(minDepth, depth);
                    maxDepth = Math.max(maxDepth, depth);
                    totalDepth += depth;
                    
                    depthBuffer[idx] = {
                        depth: depth,
                        sCoord: sCoord,
                        sMagnitude: sMagnitude,
                        isInBand: isInBand,
                        bandPosition: bandPosition,
                        distanceFromBandCenter: distanceFromBandCenter,
                        luminance: lum,
                        saturation: sat,
                        haditResult: result,
                        coverage: true
                    };
                }
            }
            
            const processingTime = performance.now() - startTime;
            const avgDepth = totalDepth / (width * height);
            const avgBandDepth = pixelsInBand > 0 ? bandDepthSum / pixelsInBand : 0;
            const avgOutsideDepth = pixelsOutsideBand > 0 ? outsideDepthSum / pixelsOutsideBand : 0;
            
            console.log(`‚úÖ Precise depth generated in ${processingTime.toFixed(2)}ms`);
            console.log(`   Œ∏=${config.haditTheta.toFixed(1)}¬∞, œÜ=${config.haditPhi.toFixed(1)}¬∞`);
            console.log(`   Pixels in band: ${pixelsInBand}/${width * height} (${(pixelsInBand/(width*height)*100).toFixed(1)}%)`);
            
            return {
                depthBuffer,
                stats: {
                    processingTime,
                    minDepth,
                    maxDepth,
                    avgDepth,
                    avgBandDepth,
                    avgOutsideDepth,
                    pixelsInBand,
                    pixelsOutsideBand,
                    bandCoverage: pixelsInBand / (width * height),
                    detectedBand: detectedBand,
                    haditTheta: config.haditTheta,
                    haditPhi: config.haditPhi,
                    focusFactor: config.focusFactor,
                    focusOnlyBand: config.focusOnlyBand,
                    bandSizeMultiplier: config.bandSizeMultiplier
                }
            };
        }

        // Keep your original 3D rotation functions exactly as they are
        function createRotationMatrix(rx, ry, rz) {
            const cos = Math.cos, sin = Math.sin;
            
            const Rx = [
                [1, 0, 0],
                [0, cos(rx), -sin(rx)],
                [0, sin(rx), cos(rx)]
            ];
            
            const Ry = [
                [cos(ry), 0, sin(ry)],
                [0, 1, 0],
                [-sin(ry), 0, cos(ry)]
            ];
            
            const Rz = [
                [cos(rz), -sin(rz), 0],
                [sin(rz), cos(rz), 0],
                [0, 0, 1]
            ];
            
            let result = multiplyMatrices(Ry, Rx);
            return multiplyMatrices(Rz, result);
        }

        function multiplyMatrices(a, b) {
            const result = [[0,0,0],[0,0,0],[0,0,0]];
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    for (let k = 0; k < 3; k++) {
                        result[i][j] += a[i][k] * b[k][j];
                    }
                }
            }
            return result;
        }

        function applyRotationMatrix(point, matrix) {
            return {
                x: matrix[0][0] * point.x + matrix[0][1] * point.y + matrix[0][2] * point.z,
                y: matrix[1][0] * point.x + matrix[1][1] * point.y + matrix[1][2] * point.z,
                z: matrix[2][0] * point.x + matrix[2][1] * point.y + matrix[2][2] * point.z
            };
        }

        // FIXED: Your original 3D view function with minimal uniform S-coordinate changes
        function generateEnhanced3DRotatedView(originalImageData, depthResult, config) {
            if (!config.enable3DRotation) return;
            
            console.log('üîÑ Generating fixed uniform 3D rotated view...');
            const startTime = performance.now();
            
            const { width, height, data } = originalImageData;
            const { rotationX, rotationY, depthScale, viewDistance, enhanceBandDepth } = config;
            
            const canvas = document.getElementById('rotatedCanvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = width;
            canvas.height = height;
            
            const outputImageData = ctx.createImageData(width, height);
            const outputData = outputImageData.data;
            
            // Clear to black
            for (let i = 0; i < outputData.length; i += 4) {
                outputData[i] = 0;
                outputData[i + 1] = 0;
                outputData[i + 2] = 0;
                outputData[i + 3] = 255;
            }
            
            const rx = rotationX * Math.PI / 180;
            const ry = rotationY * Math.PI / 180;
            const rotMatrix = createRotationMatrix(rx, ry, 0);
            
            const centerX = width / 2;
            const centerY = height / 2;
            
            // Create a Z-buffer for proper depth sorting
            const zBuffer = new Array(width * height).fill(Infinity);
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;
                    const depthData = depthResult.depthBuffer[idx];
                    
                    if (!depthData) continue;
                    
                    // MINIMAL FIX: Use effective depth from your original working code
                    let effectiveDepth = depthData.depth;
                    
                    // Apply S-magnitude based depth enhancement to ALL pixels (UNIFORM FIX)
                    const sMagnitudeNormalized = Math.min(1.0, depthData.sMagnitude / currentSBounds);
                    
                    if (depthData.isInBand && enhanceBandDepth) {
                        const bandIntensity = 1.0 - (depthData.distanceFromBandCenter / (detectedBand.width * 0.5 + 0.001));
                        effectiveDepth += sMagnitudeNormalized * depthScale * 0.3 * (1.0 + bandIntensity * 0.5);
                    } else {
                        // UNIFORM FIX: Apply S-magnitude to ALL pixels, not just H-band
                        effectiveDepth += sMagnitudeNormalized * depthScale * 0.15;
                    }
                    
                    // Create 3D position from your original working coordinates
                    const normalizedX = (x - centerX) / centerX;
                    const normalizedY = (y - centerY) / centerY;
                    
                    // UNIFORM FIX: Add small S-coordinate offset to ALL pixels
                    let pos3D = {
                        x: normalizedX + (depthData.sCoord.x * 0.02),
                        y: normalizedY + (depthData.sCoord.y * 0.02),
                        z: (effectiveDepth - 0.5) * depthScale
                    };
                    
                    // Apply rotation to the 3D position (your original working rotation)
                    const rotatedPoint = applyRotationMatrix(pos3D, rotMatrix);
                    
                    // Your original working perspective projection
                    const z = rotatedPoint.z + viewDistance;
                    
                    if (z > 0.1) {
                        const factor = viewDistance / z;
                        const projectedX = rotatedPoint.x * factor;
                        const projectedY = rotatedPoint.y * factor;
                        
                        // Map back to screen coordinates (your original working mapping)
                        const screenX = Math.round(projectedX * centerX + centerX);
                        const screenY = Math.round(projectedY * centerY + centerY);
                        
                        if (screenX >= 0 && screenX < width && screenY >= 0 && screenY < height) {
                            const targetIdx = screenY * width + screenX;
                            
                            // Z-buffer test for proper depth sorting
                            if (z < zBuffer[targetIdx]) {
                                zBuffer[targetIdx] = z;
                                
                                const sourceIdx = idx * 4;
                                const targetPixelIdx = targetIdx * 4;
                                
                                // Your original working shading calculation
                                let shading = Math.max(0.2, Math.min(1.0, 0.3 + z * 0.4));
                                
                                if (depthData.isInBand && enhanceBandDepth) {
                                    const bandIntensity = 1.0 - (depthData.distanceFromBandCenter / (detectedBand.width * 0.5 + 0.001));
                                    shading = Math.min(1.0, shading * (1.0 + bandIntensity * 0.3));
                                    
                                    // Enhanced color for H-band pixels
                                    outputData[targetPixelIdx] = Math.min(255, Math.round(data[sourceIdx] * shading * 1.1));
                                    outputData[targetPixelIdx + 1] = Math.min(255, Math.round(data[sourceIdx + 1] * shading * 1.05));
                                    outputData[targetPixelIdx + 2] = Math.min(255, Math.round(data[sourceIdx + 2] * shading));
                                } else {
                                    // Standard shading for all other pixels
                                    outputData[targetPixelIdx] = Math.round(data[sourceIdx] * shading);
                                    outputData[targetPixelIdx + 1] = Math.round(data[sourceIdx + 1] * shading);
                                    outputData[targetPixelIdx + 2] = Math.round(data[sourceIdx + 2] * shading);
                                }
                                outputData[targetPixelIdx + 3] = 255;
                            }
                        }
                    }
                }
            }
            
            ctx.putImageData(outputImageData, 0, 0);
            
            const processingTime = performance.now() - startTime;
            console.log(`‚úÖ Fixed uniform 3D view generated in ${processingTime.toFixed(2)}ms`);
        }

        // Keep ALL your visualization and stereo functions exactly as they are
        function visualizeBandFocusedDepth(depthResult, width, height, config) {
            const depthCanvas = document.getElementById('depthCanvas');
            const depthCtx = depthCanvas.getContext('2d');
            
            depthCanvas.width = width;
            depthCanvas.height = height;
            
            const imageData = depthCtx.createImageData(width, height);
            const data = imageData.data;
            
            for (let i = 0; i < depthResult.depthBuffer.length; i++) {
                const depthData = depthResult.depthBuffer[i];
                const pixelIdx = i * 4;
                
                let depth = depthData.depth;
                
                if (config.depthContrast !== 1.0) {
                    depth = Math.pow(depth, 1.0 / config.depthContrast);
                }
                
                const gray = Math.round(depth * 255);
                
                data[pixelIdx] = gray;
                data[pixelIdx + 1] = gray;
                data[pixelIdx + 2] = gray;
                data[pixelIdx + 3] = 255;
            }
            
            depthCtx.putImageData(imageData, 0, 0);
        }

        function generateStereoViews(originalImage, depthResult, config) {
            if (!config.enableStereo) return;
            
            const leftCanvas = document.getElementById('leftCanvas');
            const rightCanvas = document.getElementById('rightCanvas');
            const leftCtx = leftCanvas.getContext('2d');
            const rightCtx = rightCanvas.getContext('2d');
            
            const width = originalImage.width;
            const height = originalImage.height;
            const separation = config.separation;
            
            leftCanvas.width = width;
            leftCanvas.height = height;
            rightCanvas.width = width;
            rightCanvas.height = height;
            
            leftCtx.drawImage(originalImage, 0, 0);
            rightCtx.drawImage(originalImage, 0, 0);
            
            if (separation === 0) return;
            
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = width;
            tempCanvas.height = height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(originalImage, 0, 0);
            const originalImageData = tempCtx.getImageData(0, 0, width, height);
            
            const leftImageData = leftCtx.createImageData(width, height);
            const rightImageData = rightCtx.createImageData(width, height);
            
            for (let i = 0; i < originalImageData.data.length; i++) {
                leftImageData.data[i] = originalImageData.data[i];
                rightImageData.data[i] = originalImageData.data[i];
            }
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;
                    const depthData = depthResult.depthBuffer[idx];
                    
                    if (depthData && depthData.depth > 0) {
                        let effectiveDepth = depthData.depth;
                        
                        if (depthData.isInBand && config.focusFactor > 1.0) {
                            effectiveDepth = 0.5 + (effectiveDepth - 0.5) * config.focusFactor * 0.5;
                        }
                        
                        const normalizedDepth = (effectiveDepth - 0.5) * 2;
                        const displacement = Math.round(normalizedDepth * separation);
                        
                        const currentPixelIdx = idx * 4;
                        
                        const leftSampleX = x + displacement;
                        if (leftSampleX >= 0 && leftSampleX < width) {
                            const leftSampleIdx = (y * width + leftSampleX) * 4;
                            leftImageData.data[currentPixelIdx] = originalImageData.data[leftSampleIdx];
                            leftImageData.data[currentPixelIdx + 1] = originalImageData.data[leftSampleIdx + 1];
                            leftImageData.data[currentPixelIdx + 2] = originalImageData.data[leftSampleIdx + 2];
                        }
                        
                        const rightSampleX = x - displacement;
                        if (rightSampleX >= 0 && rightSampleX < width) {
                            const rightSampleIdx = (y * width + rightSampleX) * 4;
                            rightImageData.data[currentPixelIdx] = originalImageData.data[rightSampleIdx];
                            rightImageData.data[currentPixelIdx + 1] = originalImageData.data[rightSampleIdx + 1];
                            rightImageData.data[currentPixelIdx + 2] = originalImageData.data[rightSampleIdx + 2];
                        }
                    }
                }
            }
            
            leftCtx.putImageData(leftImageData, 0, 0);
            rightCtx.putImageData(rightImageData, 0, 0);
        }

        // Keep your original control class exactly as it is but with fixed function call
        class EnhancedHBand3DControl {
            constructor() {
                this.currentImage = null;
                this.currentImageData = null;
                this.depthResult = null;
                this.bandDetectionResult = null;
                this.isProcessing = false;
                this.animationFrame = null;
                this.isDragging = false;
                this.lastMousePos = { x: 0, y: 0 };
                
                this.initializeControls();
                this.setupInteractive3DRotation();
                this.updateInfoPanel('Fixed uniform H-band 3D rotation ready... | Angledcrystals | 2025-06-08 05:18:59 UTC');
                this.updateAnalysisPanel('Ready for fixed uniform S-coordinate application...');
                
                console.log('‚úÖ Fixed uniform H-band 3D control system initialized!');
            }

            getConfiguration() {
                return {
                    bandDetectionMode: document.getElementById('bandDetectionMode')?.value || 'auto_detect',
                    bandSizeMultiplier: parseFloat(document.getElementById('bandSizeMultiplier')?.value || 1.0),
                    focusFactor: parseFloat(document.getElementById('focusFactor')?.value || 2.0),
                    haditTheta: parseFloat(document.getElementById('haditTheta')?.value || 45),
                    haditPhi: parseFloat(document.getElementById('haditPhi')?.value || 60),
                    haditInfluence: parseFloat(document.getElementById('haditInfluence')?.value || 1.0),
                    sBounds: parseFloat(document.getElementById('sBounds')?.value || 10.0),
                    luminosityWeight: parseFloat(document.getElementById('luminosityWeight')?.value || 0.7),
                    saturationWeight: parseFloat(document.getElementById('saturationWeight')?.value || 0.3),
                    separation: parseFloat(document.getElementById('separation')?.value || 8),
                    depthContrast: parseFloat(document.getElementById('depthContrast')?.value || 1.2),
                    rotationX: parseFloat(document.getElementById('rotationX')?.value || 0),
                    rotationY: parseFloat(document.getElementById('rotationY')?.value || 0),
                    depthScale: parseFloat(document.getElementById('depthScale')?.value || 2.0),
                    viewDistance: parseFloat(document.getElementById('viewDistance')?.value || 3.0),
                    enableStereo: document.getElementById('enableStereo')?.checked ?? true,
                    showBandVisualization: document.getElementById('showBandVisualization')?.checked ?? false,
                    realTimeUpdate: document.getElementById('realTimeUpdate')?.checked ?? true,
                    focusOnlyBand: document.getElementById('focusOnlyBand')?.checked ?? false,
                    cleanDepthMap: document.getElementById('cleanDepthMap')?.checked ?? true,
                    enable3DRotation: document.getElementById('enable3DRotation')?.checked ?? true,
                    enhanceBandDepth: document.getElementById('enhanceBandDepth')?.checked ?? true
                };
            }

            // Keep ALL your original control methods exactly as they are
            initializeControls() {
                // File upload
                document.getElementById('imageUpload')?.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            const img = new Image();
                            img.onload = () => {
                                this.loadImage(img);
                            };
                            img.src = event.target.result;
                        };
                        reader.readAsDataURL(file);
                    }
                });

                // Control synchronization - keep exactly as your original
                this.setupControlSync('bandSizeMultiplier', null, 'bandSizeMultiplierValue', 'x');
                this.setupControlSync('focusFactor', null, 'focusFactorValue', 'x');
                this.setupControlSync('haditTheta', 'haditThetaNumber', 'haditThetaValue', '¬∞');
                this.setupControlSync('haditPhi', 'haditPhiNumber', 'haditPhiValue', '¬∞');
                this.setupControlSync('haditInfluence', null, 'haditInfluenceValue', '');
                this.setupControlSync('sBounds', null, 'sBoundsValue', '¬±');
                this.setupControlSync('luminosityWeight', null, 'luminosityWeightValue', '');
                this.setupControlSync('saturationWeight', null, 'saturationWeightValue', '');
                this.setupControlSync('separation', null, 'separationValue', 'px');
                this.setupControlSync('depthContrast', null, 'depthContrastValue', 'x');
                this.setupControlSync('rotationX', 'rotationXNumber', 'rotationXValue', '¬∞');
                this.setupControlSync('rotationY', 'rotationYNumber', 'rotationYValue', '¬∞');
                this.setupControlSync('depthScale', null, 'depthScaleValue', 'x');
                this.setupControlSync('viewDistance', null, 'viewDistanceValue', '');

                // Precision presets - keep exactly as your original
                document.getElementById('setHadit1Degree')?.addEventListener('click', () => this.setHaditPhi(1.0));
                document.getElementById('setHadit01Degree')?.addEventListener('click', () => this.setHaditPhi(0.1));
                document.getElementById('setHaditNearZero')?.addEventListener('click', () => this.setHaditPhi(0.5));
                document.getElementById('setHaditNear180')?.addEventListener('click', () => this.setHaditPhi(179.5));

                // 3D rotation presets - keep exactly as your original
                document.getElementById('resetRotation')?.addEventListener('click', () => this.resetRotation());
                document.getElementById('topView')?.addEventListener('click', () => this.setRotation(-20, 0));
                document.getElementById('sideView')?.addEventListener('click', () => this.setRotation(0, 30));
                document.getElementById('isometricView')?.addEventListener('click', () => this.setRotation(-15, 20));

                // Action buttons - keep exactly as your original
                document.getElementById('detectBand')?.addEventListener('click', () => this.processCurrentImage());
                document.getElementById('expandBandFull')?.addEventListener('click', () => this.expandBandToFull());
                document.getElementById('testPattern')?.addEventListener('click', () => this.generateTestPattern());
                document.getElementById('animateHadit')?.addEventListener('click', () => this.toggleHaditAnimation());
                document.getElementById('export3D')?.addEventListener('click', () => this.exportFixed3DView());
                document.getElementById('clearAll')?.addEventListener('click', () => this.clearAll());

                // Real-time updates - keep exactly as your original
                const updateTriggers = [
                    'bandDetectionMode', 'bandSizeMultiplier', 'focusFactor', 'haditTheta', 'haditPhi', 
                    'haditInfluence', 'sBounds', 'luminosityWeight', 'saturationWeight', 'separation', 
                    'depthContrast', 'rotationX', 'rotationY', 'depthScale', 'viewDistance'
                ];
                
                updateTriggers.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.addEventListener('input', () => {
                            if (this.getConfiguration().realTimeUpdate) {
                                this.processCurrentImage();
                            }
                        });
                    }
                });

                // Checkbox listeners - keep exactly as your original
                const checkboxes = ['enableStereo', 'showBandVisualization', 'focusOnlyBand', 
                                  'cleanDepthMap', 'enable3DRotation', 'enhanceBandDepth'];
                checkboxes.forEach(id => {
                    document.getElementById(id)?.addEventListener('change', () => {
                        if (this.getConfiguration().realTimeUpdate) this.processCurrentImage();
                    });
                });
            }

            setupControlSync(sliderId, numberId, labelId, suffix) {
                const slider = document.getElementById(sliderId);
                const number = numberId ? document.getElementById(numberId) : null;
                const label = document.getElementById(labelId);

                if (slider) {
                    slider.addEventListener('input', () => {
                        const value = parseFloat(slider.value);
                        if (number) number.value = value;
                        if (label) {
                            const displayValue = suffix === '¬±' ? `¬±${value.toFixed(1)}` : value.toFixed(1) + suffix;
                            label.textContent = displayValue;
                        }
                    });
                }

                if (number) {
                    number.addEventListener('input', () => {
                        const value = parseFloat(number.value);
                        if (!isNaN(value)) {
                            slider.value = value;
                            if (label) {
                                const displayValue = suffix === '¬±' ? `¬±${value.toFixed(1)}` : value.toFixed(1) + suffix;
                                label.textContent = displayValue;
                            }
                        }
                    });
                }
            }

            setupInteractive3DRotation() {
                const rotatedCanvas = document.getElementById('rotatedCanvas');
                
                rotatedCanvas.addEventListener('mousedown', (e) => {
                    this.isDragging = true;
                    this.lastMousePos = { x: e.clientX, y: e.clientY };
                    rotatedCanvas.style.cursor = 'grabbing';
                });

                document.addEventListener('mousemove', (e) => {
                    if (this.isDragging) {
                        const deltaX = e.clientX - this.lastMousePos.x;
                        const deltaY = e.clientY - this.lastMousePos.y;
                        
                        const rotX = document.getElementById('rotationX');
                        const rotY = document.getElementById('rotationY');
                        
                        const sensitivity = 0.1; // Keep your original sensitivity
                        const newRotX = Math.max(-30, Math.min(30, parseFloat(rotX.value) + deltaY * sensitivity));
                        const newRotY = Math.max(-45, Math.min(45, parseFloat(rotY.value) + deltaX * sensitivity));
                        
                        rotX.value = newRotX;
                        rotY.value = newRotY;
                        
                        if (document.getElementById('rotationXNumber')) document.getElementById('rotationXNumber').value = newRotX;
                        if (document.getElementById('rotationYNumber')) document.getElementById('rotationYNumber').value = newRotY;
                        if (document.getElementById('rotationXValue')) document.getElementById('rotationXValue').textContent = newRotX.toFixed(1) + '¬∞';
                        if (document.getElementById('rotationYValue')) document.getElementById('rotationYValue').textContent = newRotY.toFixed(1) + '¬∞';
                        
                        this.lastMousePos = { x: e.clientX, y: e.clientY };
                        
                        if (this.getConfiguration().realTimeUpdate) {
                            this.processCurrentImage();
                        }
                    }
                });

                document.addEventListener('mouseup', () => {
                    if (this.isDragging) {
                        this.isDragging = false;
                        rotatedCanvas.style.cursor = 'grab';
                    }
                });
            }

            loadImage(img) {
                this.currentImage = img;
                
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                this.currentImageData = ctx.getImageData(0, 0, img.width, img.height);
                
                this.updateInfoPanel(`Image loaded: ${img.width}x${img.height} | Processing with fixed uniform S-coordinates... | Angledcrystals | 2025-06-08 05:21:46 UTC`);
                this.processCurrentImage();
            }

            processCurrentImage() {
                if (!this.currentImageData || this.isProcessing) return;
                
                this.isProcessing = true;
                const config = this.getConfiguration();
                
                // Visual feedback
                const rotatedCanvas = document.getElementById('rotatedCanvas');
                rotatedCanvas.classList.add('processing');
                
                setTimeout(() => {
                    try {
                        // Step 1: Detect H-band
                        this.bandDetectionResult = detectHaditInformationBand(this.currentImageData, config);
                        detectedBand = this.bandDetectionResult.band;
                        
                        // Step 2: Generate band-focused depth
                        this.depthResult = generateBandFocusedDepth(this.currentImageData, config, detectedBand);
                        
                        // Step 3: Visualize depth map
                        visualizeBandFocusedDepth(this.depthResult, this.currentImageData.width, this.currentImageData.height, config);
                        
                        // Step 4: Generate stereo views
                        generateStereoViews(this.currentImage, this.depthResult, config);
                        
                        // Step 5: Generate FIXED uniform 3D view
                        if (config.enable3DRotation) {
                            generateEnhanced3DRotatedView(this.currentImageData, this.depthResult, config);
                        }
                        
                        // Update info and analysis panels
                        this.updateInfoPanel(`Fixed uniform H-band 3D processing complete | Œ∏=${config.haditTheta.toFixed(1)}¬∞, œÜ=${config.haditPhi.toFixed(1)}¬∞ | Band: ${detectedBand.min.toFixed(2)}-${detectedBand.max.toFixed(2)} | Depth Scale=${config.depthScale.toFixed(1)}x | View: X=${config.rotationX.toFixed(1)}¬∞, Y=${config.rotationY.toFixed(1)}¬∞ | Angledcrystals | 2025-06-08 05:21:46 UTC`);
                        
                        this.updateAnalysisPanel(`
‚ö° Fixed Uniform H-band 3D Analysis
üìä Band Detection: ${config.bandDetectionMode}
üéØ H-band range: ${detectedBand.min.toFixed(2)} to ${detectedBand.max.toFixed(2)}
üìà Band confidence: ${detectedBand.confidence.toFixed(3)}
üîç Pixels in band: ${this.depthResult.stats.pixelsInBand}/${this.currentImageData.width * this.currentImageData.height} (${(this.depthResult.stats.bandCoverage*100).toFixed(1)}%)
‚ö° Hadit Œ∏=${config.haditTheta.toFixed(1)}¬∞, œÜ=${config.haditPhi.toFixed(1)}¬∞
üåä Influence: ${config.haditInfluence.toFixed(1)}
üéØ Focus Factor: ${config.focusFactor.toFixed(1)}x
üìê S Bounds: ¬±${config.sBounds.toFixed(1)}
üèîÔ∏è 3D Depth Scale: ${config.depthScale.toFixed(1)}x
üîÑ View Rotation: X=${config.rotationX.toFixed(1)}¬∞, Y=${config.rotationY.toFixed(1)}¬∞
üé¨ View Distance: ${config.viewDistance.toFixed(1)}
üí° Luminosity Weight: ${config.luminosityWeight.toFixed(2)}
üåà Saturation Weight: ${config.saturationWeight.toFixed(2)}
üîß Stereo Separation: ${config.separation}px
üó∫Ô∏è Depth Contrast: ${config.depthContrast.toFixed(1)}x
üîÑ Enhanced Band Depth: ${config.enhanceBandDepth ? 'YES' : 'NO'}
üõ†Ô∏è Uniform S-Coordinate Fix: APPLIED
‚è±Ô∏è Processing time: ${this.depthResult.stats.processingTime.toFixed(2)}ms
                        `);
                        
                    } catch (error) {
                        console.error('Fixed uniform 3D processing error:', error);
                        this.updateInfoPanel('Error during fixed uniform 3D processing: ' + error.message);
                    } finally {
                        this.isProcessing = false;
                        rotatedCanvas.classList.remove('processing');
                    }
                }, 50);
            }

            setHaditPhi(value) {
                document.getElementById('haditPhi').value = value;
                document.getElementById('haditPhiNumber').value = value;
                document.getElementById('haditPhiValue').textContent = value.toFixed(1) + '¬∞';
                
                if (this.getConfiguration().realTimeUpdate) {
                    this.processCurrentImage();
                }
            }

            resetRotation() {
                document.getElementById('rotationX').value = 0;
                document.getElementById('rotationY').value = 0;
                document.getElementById('rotationXNumber').value = 0;
                document.getElementById('rotationYNumber').value = 0;
                document.getElementById('rotationXValue').textContent = '0.0¬∞';
                document.getElementById('rotationYValue').textContent = '0.0¬∞';
                
                if (this.getConfiguration().realTimeUpdate) {
                    this.processCurrentImage();
                }
            }

            setRotation(x, y) {
                document.getElementById('rotationX').value = x;
                document.getElementById('rotationY').value = y;
                document.getElementById('rotationXNumber').value = x;
                document.getElementById('rotationYNumber').value = y;
                document.getElementById('rotationXValue').textContent = x.toFixed(1) + '¬∞';
                document.getElementById('rotationYValue').textContent = y.toFixed(1) + '¬∞';
                
                if (this.getConfiguration().realTimeUpdate) {
                    this.processCurrentImage();
                }
            }

            expandBandToFull() {
                document.getElementById('bandDetectionMode').value = 'full_image';
                if (this.getConfiguration().realTimeUpdate) {
                    this.processCurrentImage();
                }
            }

            generateTestPattern() {
                const canvas = document.createElement('canvas');
                canvas.width = 400;
                canvas.height = 300;
                const ctx = canvas.getContext('2d');
                
                // Create test pattern with your original gradient
                for (let y = 0; y < canvas.height; y++) {
                    for (let x = 0; x < canvas.width; x++) {
                        const hue = (x / canvas.width) * 360;
                        const sat = 30 + (y / canvas.height) * 50;
                        const lightness = 20 + (y / canvas.height) * 60;
                        
                        ctx.fillStyle = `hsl(${hue}, ${sat}%, ${lightness}%)`;
                        ctx.fillRect(x, y, 1, 1);
                    }
                }
                
                // Add your original test shapes
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fillRect(75, 75, 75, 35);
                ctx.fillRect(250, 175, 75, 35);
                
                ctx.fillStyle = 'rgba(255, 120, 120, 0.85)';
                ctx.beginPath();
                ctx.arc(125, 125, 25, 0, 2 * Math.PI);
                ctx.fill();
                
                ctx.fillStyle = 'rgba(120, 120, 255, 0.85)';
                ctx.beginPath();
                ctx.arc(275, 105, 22, 0, 2 * Math.PI);
                ctx.fill();
                
                // Load the test pattern
                const img = new Image();
                img.onload = () => {
                    this.loadImage(img);
                };
                img.src = canvas.toDataURL();
                
                this.updateInfoPanel('Fixed uniform test pattern generated | Processing... | Angledcrystals | 2025-06-08 05:21:46 UTC');
            }

            toggleHaditAnimation() {
                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                    this.animationFrame = null;
                    document.getElementById('animateHadit').textContent = 'üåÄ Animate Hadit';
                    this.updateInfoPanel('Hadit animation stopped | Angledcrystals | 2025-06-08 05:21:46 UTC');
                } else {
                    this.startHaditAnimation();
                    document.getElementById('animateHadit').textContent = '‚èπÔ∏è Stop Animation';
                    this.updateInfoPanel('Hadit animation started | Fixed uniform S-coordinates updating... | Angledcrystals | 2025-06-08 05:21:46 UTC');
                }
            }

            startHaditAnimation() {
                let startTime = performance.now();
                
                const animate = (currentTime) => {
                    const elapsed = currentTime - startTime;
                    const cycle = (elapsed / 8000) % 1; // 8 second cycle like your original
                    
                    const theta = cycle * 360;
                    const phi = 45 + Math.sin(cycle * Math.PI * 2) * 25;
                    
                    document.getElementById('haditTheta').value = theta;
                    document.getElementById('haditThetaNumber').value = theta;
                    document.getElementById('haditThetaValue').textContent = theta.toFixed(1) + '¬∞';
                    
                    document.getElementById('haditPhi').value = phi;
                    document.getElementById('haditPhiNumber').value = phi;
                    document.getElementById('haditPhiValue').textContent = phi.toFixed(1) + '¬∞';
                    
                    this.processCurrentImage();
                    
                    this.animationFrame = requestAnimationFrame(animate);
                };
                
                this.animationFrame = requestAnimationFrame(animate);
            }

            exportFixed3DView() {
                try {
                    const canvas = document.getElementById('rotatedCanvas');
                    const config = this.getConfiguration();
                    const link = document.createElement('a');
                    link.download = `fixed-uniform-hband-3d-theta${config.haditTheta.toFixed(0)}-phi${config.haditPhi.toFixed(0)}-depth${config.depthScale.toFixed(1)}-rotX${config.rotationX.toFixed(0)}-rotY${config.rotationY.toFixed(0)}.png`;
                    link.href = canvas.toDataURL();
                    link.click();
                    
                    this.updateInfoPanel('Fixed uniform H-band 3D view exported successfully! | Angledcrystals | 2025-06-08 05:21:46 UTC');
                } catch (error) {
                    console.error('Export error:', error);
                    this.updateInfoPanel('Error exporting fixed 3D view');
                }
            }

            clearAll() {
                // Clear all canvases
                const canvases = ['leftCanvas', 'rightCanvas', 'depthCanvas', 'rotatedCanvas'];
                canvases.forEach(id => {
                    const canvas = document.getElementById(id);
                    if (canvas) {
                        const ctx = canvas.getContext('2d');
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                    }
                });
                
                // Reset data
                this.currentImage = null;
                this.currentImageData = null;
                this.depthResult = null;
                this.bandDetectionResult = null;
                
                // Stop animation if running
                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                    this.animationFrame = null;
                    document.getElementById('animateHadit').textContent = 'üåÄ Animate Hadit';
                }
                
                this.updateInfoPanel('All cleared | Fixed uniform H-band 3D rotation ready... | Angledcrystals | 2025-06-08 05:21:46 UTC');
                this.updateAnalysisPanel('Ready for fixed uniform S-coordinate application...');
            }

            updateInfoPanel(message) {
                const panel = document.getElementById('infoPanel');
                if (panel) {
                    panel.innerHTML = `<div>${message}</div>`;
                }
            }

            updateAnalysisPanel(message) {
                const panel = document.getElementById('analysisPanel');
                if (panel) {
                    panel.innerHTML = `<div style="color: #88ff00; font-weight: bold;">‚ö° Fixed Uniform H-band 3D Analysis</div><div style="white-space: pre-line; font-family: 'Courier New', monospace; font-size: 10px;">${message}</div>`;
                }
            }
        }

        // Initialize the FIXED uniform H-band 3D system
        document.addEventListener('DOMContentLoaded', () => {
            new EnhancedHBand3DControl();
        });
    </script>
</body>
</html>
