<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AndroidVR - Fine Hadit Control</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
            color: #fff;
            min-height: 100vh;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88;
            margin-bottom: 10px;
        }

        .subtitle {
            text-align: center;
            color: #888;
            font-size: 14px;
            margin-bottom: 30px;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        label {
            color: #00ff88;
            margin-bottom: 5px;
            font-size: 12px;
            text-transform: uppercase;
        }

        input[type="range"] {
            width: 100%;
            margin-bottom: 10px;
        }

        input[type="number"] {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #00ff88;
            border-radius: 5px;
            color: #fff;
            padding: 5px;
            font-size: 12px;
            width: 80px;
        }

        input[type="file"] {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #00ff88;
            border-radius: 5px;
            color: #fff;
            padding: 5px;
        }

        select, button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #00ff88;
            border-radius: 5px;
            color: #fff;
            padding: 5px;
            cursor: pointer;
        }

        button:hover {
            background: rgba(0, 255, 136, 0.2);
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
        }

        .band-control {
            background: rgba(255, 255, 0, 0.2) !important;
            border-color: #ffff00 !important;
        }

        .hadit-control {
            background: rgba(255, 0, 255, 0.2) !important;
            border-color: #ff00ff !important;
        }

        .stereo-fix {
            background: rgba(255, 68, 136, 0.2) !important;
            border-color: #ff4488 !important;
        }

        .depth-viz {
            background: rgba(255, 136, 0, 0.2) !important;
            border-color: #ff8800 !important;
        }

        .precision-control {
            background: rgba(0, 255, 255, 0.2) !important;
            border-color: #00ffff !important;
        }

        .canvas-container {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 300px;
            gap: 20px;
            margin-bottom: 20px;
        }

        canvas {
            border: 2px solid #00ff88;
            border-radius: 10px;
            background: #000;
            max-width: 100%;
            height: auto;
        }

        .left-eye { border-color: #ff4444 !important; }
        .right-eye { border-color: #4444ff !important; }
        .depth-map { border-color: #ff8800 !important; }

        .canvas-label {
            text-align: center;
            font-size: 12px;
            color: #888;
            margin-bottom: 5px;
            text-transform: uppercase;
        }

        .left-label { color: #ff4444; }
        .right-label { color: #4444ff; }
        .depth-label { color: #ff8800; }

        .analysis-panel {
            background: rgba(136, 255, 0, 0.1);
            border: 1px solid #88ff00;
            border-radius: 10px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            overflow-y: auto;
            max-height: 400px;
        }

        .info-panel {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid #00ff88;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }

        .hadit-info {
            background: rgba(255, 0, 255, 0.1);
            border: 1px solid #ff00ff;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            font-size: 12px;
        }

        .dual-input {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .dual-input input[type="range"] {
            flex: 1;
            margin-bottom: 0;
        }

        .dual-input input[type="number"] {
            flex: 0 0 auto;
        }

        .processing {
            box-shadow: 0 0 20px rgba(255, 255, 0, 0.5) !important;
            animation: processing 1s ease-in-out infinite;
        }

        @keyframes processing {
            0% { box-shadow: 0 0 20px rgba(255, 255, 0, 0.3); }
            50% { box-shadow: 0 0 40px rgba(255, 255, 0, 0.8); }
            100% { box-shadow: 0 0 20px rgba(255, 255, 0, 0.3); }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>AndroidVR - Fine Hadit Control</h1>
        <div class="subtitle">Precise Hadit Angle Control: 0.1¬∞ to 360¬∞ Range</div>

        <div class="hadit-info">
            <div style="color: #ff00ff; font-weight: bold;">‚ö° Fine Hadit Control:</div>
            <div>‚Ä¢ Œ∏ (Theta): 0¬∞ to 360¬∞ in 0.1¬∞ increments</div>
            <div>‚Ä¢ œÜ (Phi): 0.1¬∞ to 180¬∞ in 0.1¬∞ increments (no more 10¬∞ minimum!)</div>
            <div>‚Ä¢ Direct number input for exact values</div>
            <div>‚Ä¢ Synchronized sliders and number inputs</div>
            <div>‚Ä¢ Mathematical edge cases handled (œÜ=0¬∞ and œÜ=180¬∞)</div>
        </div>

        <div class="controls">
            <div class="control-group">
                <label>Image Upload</label>
                <input type="file" id="imageUpload" accept="image/*">
            </div>
            
            <div class="control-group">
                <label>üì° Band Detection Mode</label>
                <select id="bandDetectionMode" class="band-control">
                    <option value="auto_detect" selected>üîç Auto-Detect Band</option>
                    <option value="content_analysis">üìä Content Analysis</option>
                    <option value="gradient_based">üåä Gradient-Based</option>
                    <option value="statistical">üìà Statistical Analysis</option>
                    <option value="manual_range">‚úã Manual Range</option>
                    <option value="full_image">üåç Full Image Coverage</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>üîß Band Size Multiplier: <span id="bandSizeMultiplierValue">1.0x</span></label>
                <input type="range" id="bandSizeMultiplier" min="0.1" max="10.0" step="0.1" value="1.0" class="band-control">
            </div>
            
            <div class="control-group">
                <label>üéØ Focus Factor: <span id="focusFactorValue">2.0x</span></label>
                <input type="range" id="focusFactor" min="1.0" max="5.0" step="0.1" value="2.0" class="band-control">
            </div>
            
            <div class="control-group">
                <label>‚ö° Hadit Œ∏ (Theta): <span id="haditThetaValue">45.0¬∞</span></label>
                <div class="dual-input">
                    <input type="range" id="haditTheta" min="0" max="360" value="45" step="0.1" class="hadit-control">
                    <input type="number" id="haditThetaNumber" min="0" max="360" step="0.1" value="45" class="hadit-control">
                </div>
            </div>
            
            <div class="control-group">
                <label>‚ö° Hadit œÜ (Phi): <span id="haditPhiValue">60.0¬∞</span></label>
                <div class="dual-input">
                    <input type="range" id="haditPhi" min="0.1" max="179.9" value="60" step="0.1" class="hadit-control">
                    <input type="number" id="haditPhiNumber" min="0.1" max="179.9" step="0.1" value="60" class="hadit-control">
                </div>
            </div>
            
            <div class="control-group">
                <label>üåä Hadit Influence: <span id="haditInfluenceValue">1.0</span></label>
                <input type="range" id="haditInfluence" min="0" max="2" value="1.0" step="0.1" class="hadit-control">
            </div>
            
            <div class="control-group">
                <label>üìê S Bounds: <span id="sBoundsValue">¬±10.0</span></label>
                <input type="range" id="sBounds" min="1.0" max="20.0" step="0.1" value="10.0" class="band-control">
            </div>
            
            <div class="control-group">
                <label>üí° Luminosity Weight: <span id="luminosityWeightValue">0.7</span></label>
                <input type="range" id="luminosityWeight" min="0" max="1" step="0.05" value="0.7" class="band-control">
            </div>
            
            <div class="control-group">
                <label>üåà Saturation Weight: <span id="saturationWeightValue">0.3</span></label>
                <input type="range" id="saturationWeight" min="0" max="1" step="0.05" value="0.3" class="band-control">
            </div>
            
            <div class="control-group">
                <label>üîß Stereo Separation: <span id="separationValue">8px</span></label>
                <input type="range" id="separation" min="0" max="20" value="8" step="1" class="stereo-fix">
            </div>
            
            <div class="control-group">
                <label>üó∫Ô∏è Depth Contrast: <span id="depthContrastValue">1.2x</span></label>
                <input type="range" id="depthContrast" min="0.1" max="3" value="1.2" step="0.1" class="depth-viz">
            </div>
            
            <div class="control-group">
                <label>Precision Presets</label>
                <button id="setHadit1Degree" class="precision-control">Set œÜ to 1.0¬∞</button>
                <button id="setHadit01Degree" class="precision-control">Set œÜ to 0.1¬∞</button>
                <button id="setHaditNearZero" class="precision-control">Set œÜ to 0.5¬∞</button>
                <button id="setHaditNear180" class="precision-control">Set œÜ to 179.5¬∞</button>
            </div>
            
            <div class="control-group">
                <label>Actions</label>
                <button id="detectBand" class="band-control">üì° Detect Band</button>
                <button id="expandBandFull" class="band-control">üåç Expand Full</button>
                <button id="testPattern" class="stereo-fix">üéØ Test Pattern</button>
                <button id="animateHadit" class="hadit-control">üåÄ Animate Hadit</button>
                <button id="clearAll">üîÑ Clear All</button>
            </div>
            
            <div class="control-group">
                <label>Options</label>
                <label><input type="checkbox" id="enableStereo" checked> Enable Stereo</label>
                <label><input type="checkbox" id="showBandVisualization"> Show Band Viz</label>
                <label><input type="checkbox" id="realTimeUpdate" checked> Real-time Update</label>
                <label><input type="checkbox" id="focusOnlyBand"> Focus Only Band</label>
                <label><input type="checkbox" id="cleanDepthMap" checked> Clean Depth Map</label>
            </div>
        </div>

        <div class="info-panel" id="infoPanel">
            <div>Status: Fine Hadit control system ready... Angledcrystals | 2025-06-07 01:43:49 UTC</div>
        </div>

        <div class="canvas-container">
            <div>
                <div class="canvas-label left-label">Left Eye View</div>
                <canvas id="leftCanvas" width="400" height="300" class="left-eye"></canvas>
            </div>
            <div>
                <div class="canvas-label right-label">Right Eye View</div>
                <canvas id="rightCanvas" width="400" height="300" class="right-eye"></canvas>
            </div>
            <div>
                <div class="canvas-label depth-label">Fine Hadit Depth</div>
                <canvas id="depthCanvas" width="400" height="300" class="depth-map"></canvas>
            </div>
            <div class="analysis-panel" id="analysisPanel">
                <div style="color: #88ff00; font-weight: bold;">‚ö° Fine Hadit Analysis</div>
                <div>Ready for precise angle control...</div>
            </div>
        </div>
    </div>

    <script>
        // ==================== HADIT MATHEMATICS ====================
        
        const vectorOps = {
            dot: (a, b) => a.x * b.x + a.y * b.y + a.z * b.z,
            subtract: (a, b) => ({ x: a.x - b.x, y: a.y - b.y, z: a.z - b.z }),
            scale: (v, s) => ({ x: v.x * s, y: v.y * s, z: v.z * s }),
            normalize: (v) => {
                const mag = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
                return mag > 1e-10 ? vectorOps.scale(v, 1 / mag) : { x: 0, y: 0, z: 1 };
            }
        };

        function sphericalToCartesian(theta, phi) {
            // Handle edge cases for phi
            const clampedPhi = Math.max(0.1, Math.min(179.9, phi));
            
            const thetaRad = theta * Math.PI / 180;
            const phiRad = clampedPhi * Math.PI / 180;
            
            return {
                x: Math.sin(phiRad) * Math.cos(thetaRad),
                y: Math.sin(phiRad) * Math.sin(thetaRad),
                z: Math.cos(phiRad)
            };
        }

        function householderReflection(G_3d, hadit_3d) {
            const haditUnit = vectorOps.normalize(hadit_3d);
            const dotProduct = vectorOps.dot(haditUnit, G_3d);
            return vectorOps.subtract(G_3d, vectorOps.scale(haditUnit, 2 * dotProduct));
        }

        function stereographicProjection(G_reflected) {
            if (Math.abs(1 - G_reflected.z) < 1e-10) {
                return { x: 0, y: 0 };
            }
            return {
                x: G_reflected.x / (1 - G_reflected.z),
                y: G_reflected.y / (1 - G_reflected.z)
            };
        }

        // ==================== HADIT INFORMATION BAND DETECTION ====================
        
        let currentSBounds = 10.0;
        let detectedBand = { min: 0, max: 0, center: 0, width: 0, confidence: 0 };
        
        function calculateHaditModulatedSCoordinate(px, py, width, height, lum, sat, config) {
            const gTheta = (px / width) * 360;
            const gPhi = (py / height) * 180;
            const G_3d = sphericalToCartesian(gTheta, gPhi);
            
            const hadit_3d = sphericalToCartesian(config.haditTheta, config.haditPhi);
            const G_reflected = householderReflection(G_3d, hadit_3d);
            const S_hadit = stereographicProjection(G_reflected);
            
            const lumMapWeight = config.luminosityWeight;
            const satMapWeight = config.saturationWeight;
            const contentModulation = (1 + lum * lumMapWeight + sat * satMapWeight);
            
            const S_modulated = {
                x: S_hadit.x * contentModulation * config.haditInfluence,
                y: S_hadit.y * contentModulation * config.haditInfluence
            };
            
            const sMagnitude = Math.sqrt(S_modulated.x * S_modulated.x + S_modulated.y * S_modulated.y);
            
            return {
                sCoord: S_modulated,
                sMagnitude: sMagnitude,
                originalG: G_3d,
                reflectedG: G_reflected,
                haditVector: hadit_3d,
                contentModulation: contentModulation,
                luminance: lum,
                saturation: sat
            };
        }
        
        function detectHaditInformationBand(imageData, config) {
            console.log(`üì° Detecting band with Hadit Œ∏=${config.haditTheta.toFixed(1)}¬∞, œÜ=${config.haditPhi.toFixed(1)}¬∞`);
            const startTime = performance.now();
            
            const { width, height, data } = imageData;
            const sMagnitudeHistogram = new Array(200).fill(0);
            const contentHistogram = new Array(200).fill(0);
            
            const maxSMagnitude = currentSBounds * 2;
            let totalPixels = 0;
            let totalContent = 0;
            
            const sampleStep = Math.max(1, Math.floor(Math.min(width, height) / 50));
            
            for (let y = 0; y < height; y += sampleStep) {
                for (let x = 0; x < width; x += sampleStep) {
                    const pixelIdx = (y * width + x) * 4;
                    
                    const r = data[pixelIdx] / 255;
                    const g = data[pixelIdx + 1] / 255;
                    const b = data[pixelIdx + 2] / 255;
                    
                    const lum = 0.299 * r + 0.587 * g + 0.114 * b;
                    const maxCol = Math.max(r, g, b);
                    const minCol = Math.min(r, g, b);
                    const sat = maxCol > 0 ? (maxCol - minCol) / maxCol : 0;
                    
                    const result = calculateHaditModulatedSCoordinate(x, y, width, height, lum, sat, config);
                    const sMagnitude = result.sMagnitude;
                    
                    const contentImportance = lum * 0.5 + sat * 0.3 + 
                                            (Math.abs(r - g) + Math.abs(g - b) + Math.abs(b - r)) * 0.2;
                    
                    const binIndex = Math.floor((sMagnitude / maxSMagnitude) * (sMagnitudeHistogram.length - 1));
                    if (binIndex >= 0 && binIndex < sMagnitudeHistogram.length) {
                        sMagnitudeHistogram[binIndex]++;
                        contentHistogram[binIndex] += contentImportance;
                        totalContent += contentImportance;
                    }
                    
                    totalPixels++;
                }
            }
            
            let bandDetectionResult;
            
            switch (config.bandDetectionMode) {
                case 'full_image':
                    bandDetectionResult = {
                        min: 0,
                        max: maxSMagnitude * 2,
                        center: maxSMagnitude,
                        width: maxSMagnitude * 2,
                        confidence: 1.0
                    };
                    break;
                    
                case 'auto_detect':
                    bandDetectionResult = autoDetectBand(sMagnitudeHistogram, contentHistogram, maxSMagnitude, config.bandSensitivity);
                    break;
                    
                case 'content_analysis':
                    bandDetectionResult = contentBasedBandDetection(contentHistogram, maxSMagnitude, config.bandSensitivity);
                    break;
                    
                case 'gradient_based':
                    bandDetectionResult = gradientBasedBandDetection(sMagnitudeHistogram, maxSMagnitude, config.bandSensitivity);
                    break;
                    
                case 'statistical':
                    bandDetectionResult = statisticalBandDetection(sMagnitudeHistogram, contentHistogram, maxSMagnitude, config.bandSensitivity);
                    break;
                    
                case 'manual_range':
                    bandDetectionResult = {
                        min: config.manualBandMin,
                        max: config.manualBandMax,
                        center: (config.manualBandMin + config.manualBandMax) / 2,
                        width: config.manualBandMax - config.manualBandMin,
                        confidence: 1.0
                    };
                    break;
            }
            
            // Apply band size multiplier
            if (config.bandSizeMultiplier !== 1.0) {
                const originalWidth = bandDetectionResult.width;
                const newWidth = originalWidth * config.bandSizeMultiplier;
                const expansion = (newWidth - originalWidth) / 2;
                
                bandDetectionResult.min = Math.max(0, bandDetectionResult.min - expansion);
                bandDetectionResult.max = bandDetectionResult.max + expansion;
                bandDetectionResult.width = newWidth;
            }
            
            const processingTime = performance.now() - startTime;
            
            console.log(`‚úÖ Band detection completed in ${processingTime.toFixed(2)}ms`);
            console.log(`   Detected band: ${bandDetectionResult.min.toFixed(2)} to ${bandDetectionResult.max.toFixed(2)}`);
            
            return {
                band: bandDetectionResult,
                histograms: {
                    sMagnitude: sMagnitudeHistogram,
                    content: contentHistogram
                },
                stats: {
                    processingTime,
                    totalPixels,
                    totalContent,
                    maxSMagnitude,
                    samplingStep: sampleStep
                }
            };
        }
        
        function autoDetectBand(sMagnitudeHistogram, contentHistogram, maxSMagnitude, sensitivity) {
            const smoothedContent = smoothHistogram(contentHistogram, 3);
            const peaks = findHistogramPeaks(smoothedContent, sensitivity);
            
            if (peaks.length === 0) {
                return { min: 0, max: maxSMagnitude, center: maxSMagnitude / 2, width: maxSMagnitude, confidence: 0.1 };
            }
            
            const primaryPeak = peaks.reduce((max, peak) => peak.strength > max.strength ? peak : max);
            const bandHalfWidth = Math.max(0.5, maxSMagnitude * 0.1);
            const binToSMagnitude = (bin) => (bin / (smoothedContent.length - 1)) * maxSMagnitude;
            
            const bandCenter = binToSMagnitude(primaryPeak.bin);
            const bandMin = Math.max(0, bandCenter - bandHalfWidth);
            const bandMax = Math.min(maxSMagnitude, bandCenter + bandHalfWidth);
            
            return {
                min: bandMin,
                max: bandMax,
                center: bandCenter,
                width: bandMax - bandMin,
                confidence: Math.min(1.0, primaryPeak.strength / (smoothedContent.length * 0.1))
            };
        }
        
        function contentBasedBandDetection(contentHistogram, maxSMagnitude, sensitivity) {
            let totalContent = contentHistogram.reduce((sum, val) => sum + val, 0);
            if (totalContent === 0) {
                return { min: 0, max: maxSMagnitude, center: maxSMagnitude / 2, width: maxSMagnitude, confidence: 0.1 };
            }
            
            let weightedSum = 0;
            for (let i = 0; i < contentHistogram.length; i++) {
                weightedSum += i * contentHistogram[i];
            }
            const centerOfMass = weightedSum / totalContent;
            
            const threshold = totalContent * sensitivity * 0.01;
            let minBin = 0, maxBin = contentHistogram.length - 1;
            
            for (let i = 0; i < contentHistogram.length; i++) {
                if (contentHistogram[i] > threshold) {
                    minBin = i;
                    break;
                }
            }
            
            for (let i = contentHistogram.length - 1; i >= 0; i--) {
                if (contentHistogram[i] > threshold) {
                    maxBin = i;
                    break;
                }
            }
            
            const binToSMagnitude = (bin) => (bin / (contentHistogram.length - 1)) * maxSMagnitude;
            
            return {
                min: binToSMagnitude(minBin),
                max: binToSMagnitude(maxBin),
                center: binToSMagnitude(centerOfMass),
                width: binToSMagnitude(maxBin) - binToSMagnitude(minBin),
                confidence: Math.min(1.0, (maxBin - minBin) / (contentHistogram.length * 0.5))
            };
        }
        
        function gradientBasedBandDetection(sMagnitudeHistogram, maxSMagnitude, sensitivity) {
            const gradient = [];
            for (let i = 1; i < sMagnitudeHistogram.length - 1; i++) {
                gradient[i] = sMagnitudeHistogram[i + 1] - sMagnitudeHistogram[i - 1];
            }
            
            const threshold = Math.max(...gradient) * sensitivity;
            let risingEdges = [];
            let fallingEdges = [];
            
            for (let i = 0; i < gradient.length; i++) {
                if (gradient[i] > threshold) risingEdges.push(i);
                if (gradient[i] < -threshold) fallingEdges.push(i);
            }
            
            if (risingEdges.length === 0 || fallingEdges.length === 0) {
                return { min: 0, max: maxSMagnitude, center: maxSMagnitude / 2, width: maxSMagnitude, confidence: 0.1 };
            }
            
            const binToSMagnitude = (bin) => (bin / (sMagnitudeHistogram.length - 1)) * maxSMagnitude;
            const bandMin = binToSMagnitude(risingEdges[0]);
            const bandMax = binToSMagnitude(fallingEdges[fallingEdges.length - 1]);
            
            return {
                min: bandMin,
                max: bandMax,
                center: (bandMin + bandMax) / 2,
                width: bandMax - bandMin,
                confidence: Math.min(1.0, (risingEdges.length + fallingEdges.length) / 10)
            };
        }
        
        function statisticalBandDetection(sMagnitudeHistogram, contentHistogram, maxSMagnitude, sensitivity) {
            let mean = 0, variance = 0, total = 0;
            
            for (let i = 0; i < sMagnitudeHistogram.length; i++) {
                const count = sMagnitudeHistogram[i];
                mean += i * count;
                total += count;
            }
            
            if (total === 0) {
                return { min: 0, max: maxSMagnitude, center: maxSMagnitude / 2, width: maxSMagnitude, confidence: 0.1 };
            }
            
            mean /= total;
            
            for (let i = 0; i < sMagnitudeHistogram.length; i++) {
                const count = sMagnitudeHistogram[i];
                variance += Math.pow(i - mean, 2) * count;
            }
            variance /= total;
            
            const stdDev = Math.sqrt(variance);
            const bandHalfWidth = stdDev * (2 - sensitivity);
            
            const binToSMagnitude = (bin) => (bin / (sMagnitudeHistogram.length - 1)) * maxSMagnitude;
            const center = binToSMagnitude(mean);
            const bandMin = Math.max(0, center - binToSMagnitude(bandHalfWidth));
            const bandMax = Math.min(maxSMagnitude, center + binToSMagnitude(bandHalfWidth));
            
            return {
                min: bandMin,
                max: bandMax,
                center: center,
                width: bandMax - bandMin,
                confidence: Math.min(1.0, stdDev / (sMagnitudeHistogram.length * 0.2))
            };
        }
        
        function smoothHistogram(histogram, radius) {
            const smoothed = new Array(histogram.length).fill(0);
            for (let i = 0; i < histogram.length; i++) {
                let sum = 0, count = 0;
                for (let j = Math.max(0, i - radius); j <= Math.min(histogram.length - 1, i + radius); j++) {
                    sum += histogram[j];
                    count++;
                }
                smoothed[i] = sum / count;
            }
            return smoothed;
        }
        
        function findHistogramPeaks(histogram, sensitivity) {
            const peaks = [];
            const minPeakHeight = Math.max(...histogram) * sensitivity * 0.1;
            
            for (let i = 1; i < histogram.length - 1; i++) {
                if (histogram[i] > histogram[i - 1] && 
                    histogram[i] > histogram[i + 1] && 
                    histogram[i] > minPeakHeight) {
                    peaks.push({
                        bin: i,
                        strength: histogram[i]
                    });
                }
            }
            
            return peaks;
        }

        // ==================== BAND-FOCUSED DEPTH GENERATION ====================
        
        function generateBandFocusedDepth(imageData, config, detectedBand) {
            console.log('üì° Generating precise Hadit depth map...');
            const startTime = performance.now();
            
            const { width, height, data } = imageData;
            const depthBuffer = new Array(width * height);
            
            currentSBounds = config.sBounds;
            
            let minDepth = 1, maxDepth = 0, totalDepth = 0;
            let pixelsInBand = 0, pixelsOutsideBand = 0;
            let bandDepthSum = 0, outsideDepthSum = 0;
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;
                    const pixelIdx = idx * 4;
                    
                    const r = data[pixelIdx] / 255;
                    const g = data[pixelIdx + 1] / 255;
                    const b = data[pixelIdx + 2] / 255;
                    
                    const lum = 0.299 * r + 0.587 * g + 0.114 * b;
                    const maxCol = Math.max(r, g, b);
                    const minCol = Math.min(r, g, b);
                    const sat = maxCol > 0 ? (maxCol - minCol) / maxCol : 0;
                    
                    const result = calculateHaditModulatedSCoordinate(x, y, width, height, lum, sat, config);
                    const { sCoord, sMagnitude } = result;
                    
                    const isInBand = sMagnitude >= detectedBand.min && sMagnitude <= detectedBand.max;
                    const distanceFromBandCenter = Math.abs(sMagnitude - detectedBand.center);
                    const bandPosition = Math.max(0, Math.min(1, (sMagnitude - detectedBand.min) / Math.max(0.001, detectedBand.width)));
                    
                    let depth = 0.1;
                    
                    if (isInBand) {
                        pixelsInBand++;
                        
                        const bandCenteredness = detectedBand.width > 0 ? 
                            1.0 - (distanceFromBandCenter / (detectedBand.width * 0.5)) : 1.0;
                        const contentWeight = lum * 0.5 + sat * 0.3;
                        
                        depth = 0.3 + bandPosition * 0.6;
                        depth *= (1 + Math.max(0, bandCenteredness) * config.focusFactor * 0.2);
                        depth *= (1 + contentWeight * 0.3);
                        
                        bandDepthSum += depth;
                        
                    } else {
                        pixelsOutsideBand++;
                        
                        if (config.focusOnlyBand) {
                            depth = 0.05 + (lum * 0.1);
                        } else {
                            const falloffDistance = Math.min(
                                Math.abs(sMagnitude - detectedBand.min),
                                Math.abs(sMagnitude - detectedBand.max)
                            );
                            const falloffFactor = 1.0 / (1.0 + falloffDistance * 0.5);
                            depth = 0.1 + lum * 0.2 * falloffFactor;
                        }
                        
                        outsideDepthSum += depth;
                    }
                    
                    if (isInBand && config.focusFactor > 1.0) {
                        depth = 0.5 + (depth - 0.5) * config.focusFactor;
                    }
                    
                    depth = Math.max(0.05, Math.min(1.0, depth));
                    
                    minDepth = Math.min(minDepth, depth);
                    maxDepth = Math.max(maxDepth, depth);
                    totalDepth += depth;
                    
                    depthBuffer[idx] = {
                        depth: depth,
                        sCoord: sCoord,
                        sMagnitude: sMagnitude,
                        isInBand: isInBand,
                        bandPosition: bandPosition,
                        distanceFromBandCenter: distanceFromBandCenter,
                        luminance: lum,
                        saturation: sat,
                        haditResult: result,
                        coverage: true
                    };
                }
            }
            
            const processingTime = performance.now() - startTime;
            const avgDepth = totalDepth / (width * height);
            const avgBandDepth = pixelsInBand > 0 ? bandDepthSum / pixelsInBand : 0;
            const avgOutsideDepth = pixelsOutsideBand > 0 ? outsideDepthSum / pixelsOutsideBand : 0;
            
            console.log(`‚úÖ Precise depth generated in ${processingTime.toFixed(2)}ms`);
            console.log(`   Œ∏=${config.haditTheta.toFixed(1)}¬∞, œÜ=${config.haditPhi.toFixed(1)}¬∞`);
            console.log(`   Pixels in band: ${pixelsInBand}/${width * height} (${(pixelsInBand/(width*height)*100).toFixed(1)}%)`);
            
            return {
                depthBuffer,
                stats: {
                    processingTime,
                    minDepth,
                    maxDepth,
                    avgDepth,
                    avgBandDepth,
                    avgOutsideDepth,
                    pixelsInBand,
                    pixelsOutsideBand,
                    bandCoverage: pixelsInBand / (width * height),
                    detectedBand: detectedBand,
                    haditTheta: config.haditTheta,
                    haditPhi: config.haditPhi,
                    focusFactor: config.focusFactor,
                    focusOnlyBand: config.focusOnlyBand,
                    bandSizeMultiplier: config.bandSizeMultiplier
                }
            };
        }

        // ==================== CLEAN VISUALIZATION ====================
        
        function visualizeBandFocusedDepth(depthResult, width, height, config) {
            const depthCanvas = document.getElementById('depthCanvas');
            const depthCtx = depthCanvas.getContext('2d');
            
            depthCanvas.width = width;
            depthCanvas.height = height;
            
            const imageData = depthCtx.createImageData(width, height);
            const data = imageData.data;
            
            for (let i = 0; i < depthResult.depthBuffer.length; i++) {
                const depthData = depthResult.depthBuffer[i];
                const pixelIdx = i * 4;
                
                let depth = depthData.depth;
                
                if (config.depthContrast !== 1.0) {
                    depth = Math.pow(depth, 1.0 / config.depthContrast);
                }
                
                const gray = Math.round(depth * 255);
                
                // Clean depth map - pure grayscale
                data[pixelIdx] = gray;
                data[pixelIdx + 1] = gray;
                data[pixelIdx + 2] = gray;
                data[pixelIdx + 3] = 255;
            }
            
            depthCtx.putImageData(imageData, 0, 0);
        }

        function generateStereoViews(originalImage, depthResult, config) {
            if (!config.enableStereo) return;
            
            const leftCanvas = document.getElementById('leftCanvas');
            const rightCanvas = document.getElementById('rightCanvas');
            const leftCtx = leftCanvas.getContext('2d');
            const rightCtx = rightCanvas.getContext('2d');
            
            const width = originalImage.width;
            const height = originalImage.height;
            const separation = config.separation;
            
            leftCanvas.width = width;
            leftCanvas.height = height;
            rightCanvas.width = width;
            rightCanvas.height = height;
            
            leftCtx.drawImage(originalImage, 0, 0);
            rightCtx.drawImage(originalImage, 0, 0);
            
            if (separation === 0) return;
            
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = width;
            tempCanvas.height = height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(originalImage, 0, 0);
            const originalImageData = tempCtx.getImageData(0, 0, width, height);
            
            const leftImageData = leftCtx.createImageData(width, height);
            const rightImageData = rightCtx.createImageData(width, height);
            
            for (let i = 0; i < originalImageData.data.length; i++) {
                leftImageData.data[i] = originalImageData.data[i];
                rightImageData.data[i] = originalImageData.data[i];
            }
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;
                    const depthData = depthResult.depthBuffer[idx];
                    
                    if (depthData && depthData.depth > 0) {
                        let effectiveDepth = depthData.depth;
                        
                        if (depthData.isInBand && config.focusFactor > 1.0) {
                            effectiveDepth = 0.5 + (effectiveDepth - 0.5) * config.focusFactor * 0.5;
                        }
                        
                        const normalizedDepth = (effectiveDepth - 0.5) * 2;
                        const displacement = Math.round(normalizedDepth * separation);
                        
                        const currentPixelIdx = idx * 4;
                        
                        const leftSampleX = x + displacement;
                        if (leftSampleX >= 0 && leftSampleX < width) {
                            const leftSampleIdx = (y * width + leftSampleX) * 4;
                            leftImageData.data[currentPixelIdx] = originalImageData.data[leftSampleIdx];
                            leftImageData.data[currentPixelIdx + 1] = originalImageData.data[leftSampleIdx + 1];
                            leftImageData.data[currentPixelIdx + 2] = originalImageData.data[leftSampleIdx + 2];
                        }
                        
                        const rightSampleX = x - displacement;
                        if (rightSampleX >= 0 && rightSampleX < width) {
                            const rightSampleIdx = (y * width + rightSampleX) * 4;
                            rightImageData.data[currentPixelIdx] = originalImageData.data[rightSampleIdx];
                            rightImageData.data[currentPixelIdx + 1] = originalImageData.data[rightSampleIdx + 1];
                            rightImageData.data[currentPixelIdx + 2] = originalImageData.data[rightSampleIdx + 2];
                        }
                    }
                }
            }
            
            leftCtx.putImageData(leftImageData, 0, 0);
            rightCtx.putImageData(rightImageData, 0, 0);
        }

        // ==================== MAIN APPLICATION ====================
        
        class FineHaditControl {
            constructor() {
                this.currentImage = null;
                this.currentImageData = null;
                this.depthResult = null;
                this.bandDetectionResult = null;
                this.isProcessing = false;
                this.animationFrame = null;
                
                this.initializeControls();
                this.updateInfoPanel('Fine Hadit control system ready! | Angledcrystals | 2025-06-07 01:43:49 UTC');
                console.log('‚úÖ Fine Hadit control system initialized!');
                console.log('œÜ (Phi) range: 0.1¬∞ to 179.9¬∞ in 0.1¬∞ increments');
                console.log('Œ∏ (Theta) range: 0¬∞ to 360¬∞ in 0.1¬∞ increments');
            }

            getConfiguration() {
                return {
                    bandDetectionMode: document.getElementById('bandDetectionMode')?.value || 'auto_detect',
                    bandSizeMultiplier: parseFloat(document.getElementById('bandSizeMultiplier')?.value || 1.0),
                    focusFactor: parseFloat(document.getElementById('focusFactor')?.value || 2.0),
                    haditTheta: parseFloat(document.getElementById('haditTheta')?.value || 45),
                    haditPhi: parseFloat(document.getElementById('haditPhi')?.value || 60),
                    haditInfluence: parseFloat(document.getElementById('haditInfluence')?.value || 1.0),
                    sBounds: parseFloat(document.getElementById('sBounds')?.value || 10.0),
                    luminosityWeight: parseFloat(document.getElementById('luminosityWeight')?.value || 0.7),
                    saturationWeight: parseFloat(document.getElementById('saturationWeight')?.value || 0.3),
                    separation: parseFloat(document.getElementById('separation')?.value || 8),
                    depthContrast: parseFloat(document.getElementById('depthContrast')?.value || 1.2),
                    enableStereo: document.getElementById('enableStereo')?.checked ?? true,
                    showBandVisualization: document.getElementById('showBandVisualization')?.checked ?? false,
                    realTimeUpdate: document.getElementById('realTimeUpdate')?.checked ?? true,
                    focusOnlyBand: document.getElementById('focusOnlyBand')?.checked ?? false,
                    cleanDepthMap: document.getElementById('cleanDepthMap')?.checked ?? true
                };
            }

            initializeControls() {
                // File upload
                document.getElementById('imageUpload')?.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            const img = new Image();
                            img.onload = () => {
                                this.loadImage(img);
                            };
                            img.src = event.target.result;
                        };
                        reader.readAsDataURL(file);
                    }
                });

                // Synchronized dual inputs for theta
                const thetaSlider = document.getElementById('haditTheta');
                const thetaNumber = document.getElementById('haditThetaNumber');
                
                thetaSlider?.addEventListener('input', () => {
                    thetaNumber.value = thetaSlider.value;
                    this.updateControlValues();
                    if (this.getConfiguration().realTimeUpdate) {
                        this.debounceUpdate();
                    }
                });
                
                thetaNumber?.addEventListener('input', () => {
                    const value = Math.max(0, Math.min(360, parseFloat(thetaNumber.value) || 0));
                    thetaSlider.value = value;
                    thetaNumber.value = value;
                    this.updateControlValues();
                    if (this.getConfiguration().realTimeUpdate) {
                        this.debounceUpdate();
                    }
                });

                // Synchronized dual inputs for phi
                const phiSlider = document.getElementById('haditPhi');
                const phiNumber = document.getElementById('haditPhiNumber');
                
                phiSlider?.addEventListener('input', () => {
                    phiNumber.value = phiSlider.value;
                    this.updateControlValues();
                    if (this.getConfiguration().realTimeUpdate) {
                        this.debounceUpdate();
                    }
                });
                
                phiNumber?.addEventListener('input', () => {
                    const value = Math.max(0.1, Math.min(179.9, parseFloat(phiNumber.value) || 0.1));
                    phiSlider.value = value;
                    phiNumber.value = value;
                    this.updateControlValues();
                    if (this.getConfiguration().realTimeUpdate) {
                        this.debounceUpdate();
                    }
                });

                // Preset buttons
                document.getElementById('setHadit1Degree')?.addEventListener('click', () => {
                    phiSlider.value = 1.0;
                    phiNumber.value = 1.0;
                    this.updateControlValues();
                    this.performBandDetection();
                });

                document.getElementById('setHadit01Degree')?.addEventListener('click', () => {
                    phiSlider.value = 0.1;
                    phiNumber.value = 0.1;
                    this.updateControlValues();
                    this.performBandDetection();
                });

                document.getElementById('setHaditNearZero')?.addEventListener('click', () => {
                    phiSlider.value = 0.5;
                    phiNumber.value = 0.5;
                    this.updateControlValues();
                    this.performBandDetection();
                });

                document.getElementById('setHaditNear180')?.addEventListener('click', () => {
                    phiSlider.value = 179.5;
                    phiNumber.value = 179.5;
                    this.updateControlValues();
                    this.performBandDetection();
                });

                // Action buttons
                document.getElementById('detectBand')?.addEventListener('click', () => {
                    if (this.currentImage && !this.isProcessing) {
                        this.performBandDetection();
                    }
                });

                document.getElementById('expandBandFull')?.addEventListener('click', () => {
                    if (this.currentImage && !this.isProcessing) {
                        document.getElementById('bandDetectionMode').value = 'full_image';
                        document.getElementById('bandSizeMultiplier').value = '10.0';
                        this.updateControlValues();
                        this.performBandDetection();
                    }
                });

                document.getElementById('testPattern')?.addEventListener('click', () => {
                    this.generateTestPattern();
                });

                document.getElementById('animateHadit')?.addEventListener('click', () => {
                    this.toggleHaditAnimation();
                });

                document.getElementById('clearAll')?.addEventListener('click', () => {
                    this.clearAll();
                });

                // Other controls
                const controls = [
                    'bandSizeMultiplier', 'focusFactor', 'haditInfluence',
                    'sBounds', 'luminosityWeight', 'saturationWeight', 'separation', 'depthContrast'
                ];
                
                controls.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.addEventListener('input', () => {
                            this.updateControlValues();
                            if (this.getConfiguration().realTimeUpdate) {
                                this.debounceUpdate();
                            }
                        });
                    }
                });

                // Method changes
                ['bandDetectionMode'].forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.addEventListener('change', () => {
                            if (this.currentImage && !this.isProcessing) {
                                this.performBandDetection();
                            }
                        });
                    }
                });

                // Checkboxes
                ['enableStereo', 'showBandVisualization', 'realTimeUpdate', 'focusOnlyBand', 'cleanDepthMap'].forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.addEventListener('change', () => {
                            if (this.depthResult) {
                                if (['focusOnlyBand'].includes(id)) {
                                    this.performBandDetection();
                                } else {
                                    this.updateVisualization();
                                }
                            }
                        });
                    }
                });

                this.updateControlValues();
            }

            debounceUpdate() {
                clearTimeout(this.updateTimer);
                this.updateTimer = setTimeout(() => {
                    if (this.currentImage && !this.isProcessing) {
                        this.performBandDetection();
                    }
                }, 100);
            }

            updateControlValues() {
                const controls = [
                    { id: 'bandSizeMultiplier', suffix: 'x' },
                    { id: 'focusFactor', suffix: 'x' },
                    { id: 'haditTheta', suffix: '¬∞', precision: 1 },
                    { id: 'haditPhi', suffix: '¬∞', precision: 1 },
                    { id: 'haditInfluence', suffix: '' },
                    { id: 'sBounds', suffix: '', prefix: '¬±' },
                    { id: 'luminosityWeight', suffix: '' },
                    { id: 'saturationWeight', suffix: '' },
                    { id: 'separation', suffix: 'px' },
                    { id: 'depthContrast', suffix: 'x' }
                ];

                controls.forEach(({ id, suffix, prefix, precision }) => {
                    const element = document.getElementById(id);
                    const valueElement = document.getElementById(id + 'Value');
                    if (element && valueElement) {
                        const prefixText = prefix || '';
                        const value = precision ? parseFloat(element.value).toFixed(precision) : element.value;
                        valueElement.textContent = prefixText + value + suffix;
                    }
                });
            }

            updateInfoPanel(message) {
                const infoPanel = document.getElementById('infoPanel');
                if (infoPanel) {
                    const timestamp = new Date().toLocaleTimeString();
                    infoPanel.innerHTML = `<div>${timestamp}: ${message}</div>`;
                }
            }

            loadImage(img) {
                this.currentImage = img;
                
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                this.currentImageData = ctx.getImageData(0, 0, img.width, img.height);
                
                this.performBandDetection();
                
                const config = this.getConfiguration();
                this.updateInfoPanel(`Image loaded (${img.width}x${img.height}). Precise Hadit: Œ∏=${config.haditTheta.toFixed(1)}¬∞, œÜ=${config.haditPhi.toFixed(1)}¬∞`);
            }

            performBandDetection() {
                if (!this.currentImage || !this.currentImageData || this.isProcessing) return;

                this.isProcessing = true;
                document.getElementById('depthCanvas').classList.add('processing');

                try {
                    const config = this.getConfiguration();
                    
                    this.updateInfoPanel(`Processing with precise Hadit: Œ∏=${config.haditTheta.toFixed(1)}¬∞, œÜ=${config.haditPhi.toFixed(1)}¬∞...`);
                    
                    this.bandDetectionResult = detectHaditInformationBand(this.currentImageData, config);
                    detectedBand = this.bandDetectionResult.band;
                    
                    this.depthResult = generateBandFocusedDepth(
                        this.currentImageData, 
                        config, 
                        this.bandDetectionResult.band
                    );
                    
                    this.updateVisualization();
                    this.updateAnalysisPanel();
                    
                    const band = this.bandDetectionResult.band;
                    const coverage = this.depthResult.stats.bandCoverage * 100;
                    this.updateInfoPanel(`Fine control complete! Œ∏=${config.haditTheta.toFixed(1)}¬∞, œÜ=${config.haditPhi.toFixed(1)}¬∞, coverage: ${coverage.toFixed(1)}%`);

                } catch (error) {
                    console.error('Error during fine Hadit processing:', error);
                    this.updateInfoPanel('Error during processing: ' + error.message);
                } finally {
                    this.isProcessing = false;
                    document.getElementById('depthCanvas').classList.remove('processing');
                }
            }

            updateVisualization() {
                const config = this.getConfiguration();
                
                if (this.depthResult) {
                    visualizeBandFocusedDepth(
                        this.depthResult,
                        this.currentImage.width,
                        this.currentImage.height,
                        config
                    );
                }
                
                if (this.currentImage && this.depthResult) {
                    generateStereoViews(this.currentImage, this.depthResult, config);
                }
            }

            updateAnalysisPanel() {
                if (!this.depthResult || !this.bandDetectionResult) return;

                const depthStats = this.depthResult.stats;
                const band = this.bandDetectionResult.band;
                const analysisPanel = document.getElementById('analysisPanel');
                
                if (analysisPanel) {
                    analysisPanel.innerHTML = `
                        <div style="color: #88ff00; font-weight: bold;">‚ö° Fine Hadit Analysis</div>
                        <div>Œ∏ (Theta): ${depthStats.haditTheta.toFixed(1)}¬∞</div>
                        <div>œÜ (Phi): ${depthStats.haditPhi.toFixed(1)}¬∞</div>
                        <div>Size Multiplier: ${depthStats.bandSizeMultiplier}x</div>
                        <div>Band Range: ${band.min.toFixed(2)} - ${band.max.toFixed(2)}</div>
                        <div>Band Width: ${band.width.toFixed(2)}</div>
                        <div>Confidence: ${(band.confidence * 100).toFixed(1)}%</div>
                        <div>Coverage: ${(depthStats.bandCoverage * 100).toFixed(1)}%</div>
                        <div>Pixels in Band: ${depthStats.pixelsInBand}</div>
                        <div>Avg Band Depth: ${depthStats.avgBandDepth.toFixed(3)}</div>
                        <div>Focus Factor: ${depthStats.focusFactor}x</div>
                        <div>Processing: ${depthStats.processingTime.toFixed(2)}ms</div>
                    `;
                }
            }

            toggleHaditAnimation() {
                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                    this.animationFrame = null;
                    document.getElementById('animateHadit').textContent = 'üåÄ Animate Hadit';
                    this.updateInfoPanel('Fine Hadit animation stopped.');
                } else {
                    document.getElementById('animateHadit').textContent = '‚èπÔ∏è Stop Animation';
                    this.updateInfoPanel('Fine Hadit animation started - 0.1¬∞ precision.');
                    
                    let animationTime = 0;
                    const animate = () => {
                        if (this.currentImage) {
                            animationTime += 0.1; // 0.1 degree precision
                            const newTheta = (animationTime % 360);
                            document.getElementById('haditTheta').value = newTheta.toFixed(1);
                            document.getElementById('haditThetaNumber').value = newTheta.toFixed(1);
                            this.updateControlValues();
                            
                            this.performBandDetection();
                        }
                        
                        this.animationFrame = requestAnimationFrame(animate);
                    };
                    
                    this.animationFrame = requestAnimationFrame(animate);
                }
            }

            generateTestPattern() {
                const canvas = document.createElement('canvas');
                canvas.width = 320;
                canvas.height = 240;
                const ctx = canvas.getContext('2d');

                // Create test pattern specifically for testing fine Hadit angle control
                
                // Radial gradient background with fine angular details
                for (let x = 0; x < 320; x++) {
                    for (let y = 0; y < 240; y++) {
                        const centerX = 160, centerY = 120;
                        const angle = Math.atan2(y - centerY, x - centerX) * 180 / Math.PI;
                        const distance = Math.sqrt((x - centerX) * (x - centerX) + (y - centerY) * (y - centerY));
                        
                        // Create fine angular patterns that should be sensitive to 0.1¬∞ changes
                        const angularPattern = Math.sin(angle * Math.PI / 5) * 0.3 + 0.7; // 5¬∞ period
                        const radialPattern = Math.sin(distance * 0.1) * 0.2 + 0.8;
                        const intensity = angularPattern * radialPattern;
                        
                        const gray = Math.round(intensity * 255);
                        ctx.fillStyle = `rgb(${gray}, ${gray}, ${gray})`;
                        ctx.fillRect(x, y, 1, 1);
                    }
                }

                // Add precise angular features for testing fine Hadit control
                
                // 1¬∞ precision test markers
                for (let degree = 0; degree < 360; degree += 1) {
                    const rad = degree * Math.PI / 180;
                    const x = 160 + Math.cos(rad) * 80;
                    const y = 120 + Math.sin(rad) * 80;
                    
                    if (degree % 10 === 0) {
                        // Major markers every 10¬∞
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(x, y, 3, 0, 2 * Math.PI);
                        ctx.fill();
                    } else if (degree % 5 === 0) {
                        // Minor markers every 5¬∞
                        ctx.fillStyle = '#cccccc';
                        ctx.beginPath();
                        ctx.arc(x, y, 2, 0, 2 * Math.PI);
                        ctx.fill();
                    } else {
                        // 1¬∞ precision markers
                        ctx.fillStyle = '#888888';
                        ctx.beginPath();
                        ctx.arc(x, y, 1, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                }

                // Special test features for extreme phi angles
                
                // Near œÜ=0¬∞ test (top pole)
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(150, 10, 20, 10);
                ctx.fillText('œÜ‚âà0¬∞', 152, 25);
                
                // Near œÜ=180¬∞ test (bottom pole)
                ctx.fillStyle = '#0000ff';
                ctx.fillRect(150, 220, 20, 10);
                ctx.fillText('œÜ‚âà180¬∞', 148, 215);
                
                // œÜ=1¬∞ test area
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(160, 30, 15, 0, 2 * Math.PI);
                ctx.fill();
                ctx.fillStyle = '#000000';
                ctx.fillText('1¬∞', 155, 35);
                
                // High-contrast test areas for different angles
                const testAngles = [0.1, 0.5, 1.0, 5.0, 45.0, 90.0, 135.0, 179.5, 179.9];
                testAngles.forEach((angle, index) => {
                    const x = 40 + (index % 3) * 120;
                    const y = 60 + Math.floor(index / 3) * 60;
                    
                    ctx.fillStyle = index % 2 === 0 ? '#ffffff' : '#000000';
                    ctx.fillRect(x, y, 30, 20);
                    
                    ctx.fillStyle = index % 2 === 0 ? '#000000' : '#ffffff';
                    ctx.font = '10px monospace';
                    ctx.fillText(`${angle}¬∞`, x + 2, y + 12);
                });

                canvas.toBlob((blob) => {
                    const img = new Image();
                    img.onload = () => {
                        this.loadImage(img);
                        this.updateInfoPanel('Fine Hadit test pattern loaded! Try 0.1¬∞, 1¬∞, and extreme angles.');
                    };
                    img.src = URL.createObjectURL(blob);
                });
            }

            clearAll() {
                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                    this.animationFrame = null;
                    document.getElementById('animateHadit').textContent = 'üåÄ Animate Hadit';
                }
                
                this.currentImage = null;
                this.currentImageData = null;
                this.depthResult = null;
                this.bandDetectionResult = null;
                detectedBand = { min: 0, max: 0, center: 0, width: 0, confidence: 0 };
                
                ['leftCanvas', 'rightCanvas', 'depthCanvas'].forEach(id => {
                    const canvas = document.getElementById(id);
                    if (canvas) {
                        const ctx = canvas.getContext('2d');
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                    }
                });

                this.updateInfoPanel('All cleared. Upload a new image for fine Hadit angle control.');
                
                const analysisPanel = document.getElementById('analysisPanel');
                if (analysisPanel) {
                    analysisPanel.innerHTML = `
                        <div style="color: #88ff00; font-weight: bold;">‚ö° Fine Hadit Analysis</div>
                        <div>Ready for precise angle control...</div>
                    `;
                }
            }
        }

        // ==================== INITIALIZATION ====================
        
        document.addEventListener('DOMContentLoaded', () => {
            console.log('‚ö° Initializing Fine Hadit Control System...');
            console.log('Current Date and Time (UTC): 2025-06-07 01:46:58');
            console.log('Current User Login: Angledcrystals');
            console.log('œÜ (Phi) range: 0.1¬∞ to 179.9¬∞ (FULL RANGE!)');
            console.log('Œ∏ (Theta) range: 0¬∞ to 360¬∞ with 0.1¬∞ precision');
            try {
                window.app = new FineHaditControl();
                console.log('‚úÖ Fine Hadit control system ready!');
            } catch (error) {
                console.error('‚ùå Initialization failed:', error);
            }
        });

        // Auto-load test pattern
        window.addEventListener('load', () => {
            setTimeout(() => {
                const testBtn = document.getElementById('testPattern');
                if (testBtn) {
                    console.log('üéØ Auto-loading fine Hadit test pattern...');
                    testBtn.click();
                }
            }, 500);
        });

    </script>
</body>
</html>
